<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你好可爱</title>
  
  
  <link href="https://wjldarling.top/atom.xml" rel="self"/>
  
  <link href="https://wjldarling.top/"/>
  <updated>2023-08-03T16:00:00.000Z</updated>
  <id>https://wjldarling.top/</id>
  
  <author>
    <name>你好可爱</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用JavaScript创建一个灵活且响应迅速的网页设计</title>
    <link href="https://wjldarling.top/posts/38e1ff4a.html"/>
    <id>https://wjldarling.top/posts/38e1ff4a.html</id>
    <published>2023-08-03T16:00:00.000Z</published>
    <updated>2023-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用-JavaScript-创建一个灵活且响应迅速的网页设计"><a href="#用-JavaScript-创建一个灵活且响应迅速的网页设计" class="headerlink" title="用 JavaScript 创建一个灵活且响应迅速的网页设计"></a>用 JavaScript 创建一个灵活且响应迅速的网页设计</h1><p>&emsp;&emsp;前段时间写了一个数据可视化大屏的项目，从纯 h5c3+js 的一个页面改成一个 vue3 的小项目，因为是数据可视化大屏这种需要适配更大的屏幕，所以单位应该设置适配从而在大屏上进行显示，基本的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">flexible</span>(<span class="params"><span class="variable language_">window</span>, <span class="variable language_">document</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取整个html文档根元素</span></span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line">  <span class="comment">// 用于获取设备的像素密度(dpr)，如果设备支持获取DPR，则获取实际DPR值，否则默认设置为1</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="variable language_">window</span>.<span class="property">devicePixelRatio</span> || <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于根据设备的DPR动态调整&lt;body&gt;元素的字体大小。它将&lt;body&gt;元素的字体大小设置为 12乘以 DPR后的值，以并像素（px）为单位</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setBodyFontSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="number">12</span> * dpr + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, setBodyFontSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setBodyFontSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于根据页面的宽度动态调整&lt;html&gt;元素的字体大小（rem单位）。它将页面的宽度除以24后作为rem的值，并以像素（px）为单位设置给&lt;html&gt;元素的字体大小。</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">setRemUnit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> rem = docEl.<span class="property">clientWidth</span> / <span class="number">24</span>;</span><br><span class="line">    docEl.<span class="property">style</span>.<span class="property">fontSize</span> = rem + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setRemUnit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听窗口的resize事件，当页面尺寸改变时，重新调用setRemUnit函数来更新&lt;html&gt;元素的字体大小</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, setRemUnit);</span><br><span class="line">  <span class="comment">// 监听窗口的pageshow事件，这个事件在页面被加载时触发，</span></span><br><span class="line">  <span class="comment">// 包括从缓存中加载。如果在缓存中加载，即e.persisted为true，则重新调用setRemUnit函数来更新&lt;html&gt;元素的字体大小</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;pageshow&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="property">persisted</span>) &#123;</span><br><span class="line">      <span class="title function_">setRemUnit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于检测是否支持0.5像素的边框。</span></span><br><span class="line">  <span class="comment">// 在设备的DPR大于等于2的情况下，创建一个临时的测试元素（&lt;div&gt;），设置其边框样式为0.5像素的透明边框，并添加到文档中。</span></span><br><span class="line">  <span class="comment">// 然后检查这个元素的高度是否为1像素，如果是，则说明设备支持0.5像素的边框，</span></span><br><span class="line">  <span class="comment">// 此时会在&lt;html&gt;元素上添加一个名为&quot;hairlines&quot;的类，以便在CSS中可以应用特定样式来修复一些在高DPR设备上边框显示不清晰的问题</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    testElement.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;.5px solid transparent&quot;</span>;</span><br><span class="line">    fakeBody.<span class="title function_">appendChild</span>(testElement);</span><br><span class="line">    docEl.<span class="title function_">appendChild</span>(fakeBody);</span><br><span class="line">    <span class="keyword">if</span> (testElement.<span class="property">offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;hairlines&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.<span class="title function_">removeChild</span>(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>, <span class="variable language_">document</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该段代码能够创建一个灵活和响应迅速的网页设计。通过动态调整字体大小并检测对 0.5 像素边框的支持，可以确保我们的网页在不同像素密度的各种设备上看起来清晰明了。在项目中使用这段代码，并配合 CSS 中的 rem 单位，可以让你在不同设备上以统一的视觉效果展示数据可视化大屏。</p><p>项目中使用的话，可以放在<code>src/utils/flexible.js</code>文件中，在<code>main.js</code>文件中直接引入即可使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./utils/flexible&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时在 css 样式中，可以用 rem 单位代替 px，其中项目页面是以 1920px 为宽度，适配之后 1rem = 80px，示例如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.475rem</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;另外，推荐这个 VSCode 插件可以帮助你更方便地进行 px 到 rem 的单位转换，提高开发效率。尤其在移动端适配过程中，能够帮助你快速计算合适的 rem 值。<br><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/14.webp" alt=""></p><p>需要进行扩展设置，设置好相应的宽度，就可以进行快速转换了</p><p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/15.webp" alt=""><br><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/16.webp" alt=""></p>]]></content>
    
    
    <summary type="html">在不同设备上以统一的视觉效果展示数据可视化大屏</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
    <category term="数据可视化" scheme="https://wjldarling.top/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="适配" scheme="https://wjldarling.top/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>奇怪性知识-做爱到底是什么感觉</title>
    <link href="https://wjldarling.top/posts/a17f3e1f.html"/>
    <id>https://wjldarling.top/posts/a17f3e1f.html</id>
    <published>2023-07-26T07:43:00.000Z</published>
    <updated>2023-07-26T08:02:59.202Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="47cc458f242f03b52a5227447fb917b93fc80de700437833854e5e8d2f8f15e7">00551be047d692052ba4758273c2a35b69be5b3dda7f17fc27b2a18413b091e35e71fb2766250834d96d034f384d202aa7370b9bb6f989abd1e6fc849983bba06391668d8402f01d30e78ad82bd0952efe72fa88cdb962a52c3c00f40d5989f42c9b1e19b1a78add3cdf50538334125cc3d590afa9160dc387e3e45a080c140f6ff0d22f44564515adb9d77ca51d6fd6e73f1e73de1229858a647d031d7779f2f3e09e9db668fdcf44d6e83b9fa726c8287d524b19a333baace6e18fa9b06ddc1dff714147c1942444977ed38edf111912000706dc471d1161fda88641b703250ce00d039a94b27f2508af46acf4c9639ea25387519d9dbf5e5daf64530f601d1405a5c58069549fdcb72075fcfbe24a8f192c7b4a6f8945d72ac0b64b9837fccaa410deffd2b228ed3f23924aafd3887112164ead08cd809d896e3502f88da11f15ef95b6eb87e22af3e33bf450abf92cb939f1f28bffe1aec5696951a7f98ccbef08ba047b20149034f36b55c9e17fcdb3ca20fa152ddedeb3714f2300c898b04a800cdee581af4cbd2fa1d0aa5ab40c67aff72ef121af69904790e9687237e2402d1583ab483baa78613ceaf00c41d8a42e5b0b4b0be88fc0d589b7dc96b2f45a4b4bebef5933b90168ca56eee3cd2642910e4a94682e670d75e7abca19a7acb16e3e8812ed137c038932cb52905c998eaae1bdf73f81d6c8c5aae7d17b23d0746e74ff5e9429969fe46159071a96e08a58dada4a80a91af9581dabeae7db6c71169097f934d97a47719dae1e809cd9325bfb369996de5693e40f36cf5c823d547a35b96131acce666f243d97472d181b2b61d15a149968781f235e5887eeabfa7bec832a2653752726bfece06fc7a02db14b8e273fd745352b210c73f6155be1d82ad9d3c12d79f2f6364e41b8b7ee1ffc61c251c74b13bad26c41f525f7d502467588311a3ab40676d6f55f402e0f4b68584b6390daf62c7ee667c35657372a42aa5fc1f66a435584a1b09ffa3c9e4159113cb28d91edae435844e1497ea730af96866749ecd4f4ff295acf698f3d36147d882f6f16ae8ff25b16954602b59175d41b8149298a292e6f944eb71fa46984d40130f5ca9eba2f5436b1447665a6083b0461ce1642cc11d5223b2f2e1b98d68e9a278a8627cc086ab744f71b8468e34776178385831867b5247b4ddc2fbd7195bf36ea9710932622ae1d6625caff6247ce90e374d9d11b4205c214a1537872a4e363d3d3fecdba6841af84cdcfd323f697985da67c845add75f46b2471fcbf58364c882ddfd97d50c661723a73d0882822eca52404d0d66800806148c4a645f7478ad2adfa05f7ca66290677a393ff44607a43820f0bb0d0feeeaa0b913cc40b2af74125581efda13c9f9017b1ab84ff664a4e82d5153938e234c305a6792462c597e545012eeae13dcee02801138e3ffca8d889c76e436211da1c4ed92d181a10baf8d234e0fdfc4ef06143e4006307d5e15c3e97b54bf6276855655bf44e6fc8870a8aebc2b5c2359bc099aba357bd8aa1fc31e8997e9c643a9a0495fbe2a56536a340389b46b3712130d8ef126bc5bc0813ef565be8b50c84d15bc59012290cca192b745ad8d77099bb6467e2e4519f76ec2f0df28c8d3699690e84f6bd6f718adb78a8f65529c71e5383c1680e2a4a9d02b78942eb69517b26091de105994bf5fa2d3214406aabf123490f45762bbb4ab1afa68f09c18162f1338a9442ddbf915a3994f5b4549e55090f22c9be3f6c96a380708bc9e9932dd9031ff7031505b8a191a5c9265ee5a2ca00e7d6ec0461bc8bc7813bb76cebba4d5b20fd8fbf859b660f63cc713d9dc3053dc3eb89cad192d6102603df59312add7edca39f60625a2a517fa4e8e35ba31e10d9473ae2e03da9e427de6f5b9851debe05861d5b36caf5607e0fdf6faab824704424c71e65761666ce97fe092165f4207898defde8372cc48ff2c8c226178da44aebdbcb9a401849e87bf9009d2b76755632cbce70297727fff0aee4ccb4f19c132855a6716ceaee5bae895ff32b3589ac1b83f49c9a8a284d423196edf951a55b1aa0222981a353d5157efe1bdcc84aefeb5985f16dfda52112ab18af89e361fab917c61a6ffb1834c6bf4d87d9d88733e2d3517d9f4b919e14b6e9b03bf3acbe9799b91933b586b60df99e20b8ef8c727a4f25966feeeb76781ee48a76b9e4047c12e307404067017de99a2ab1fe30437bbac712a6053e2663f3f5b04d0eecf5bba91091693a9b43c9c6dca9add811a3be1c1f65059d18bd09491faa31e9bd9d860a9aea9cf21d5b831fbfd2b16f43707e732d01a748997c7b2fa921c36aa8f78845856be8088713e30de21fcf136ad1fc81338855820e5213eeba5f4a0177c5b43255080416d84d0dda7f81b2296ee18be76fcd75ce0e31f4705881fc01bcf6de84452f4930646c9a4e8200570b5d3cc394472b2fcf4759883741e143d9985ad25f9c4276bd6a45b63ecd30aef2cd803266c16bef6359cd0de936cdc9e612e3fae7296b28cb086ba8545196b9ca321d08f27cedd11183e0dbc0db179904da1f5ea17f7dbdb16bf98e10044714c2584a31119108fe01a39d82f69d6208d64023e9395e45141a7fe5ed0df51648bd5627a878a8643a5d894a4dbb794a771d4e2cdc9b2489a3eebd48b44b905e5ac9d106bc75b7c772cdcbb1e5ac2b0e766668cce5fcde64f1b30a583ad46bec5de7d5876b4086c385e21cb7b10cc609a662dbd214db79d4a966161cbcb25ab631d50e5670894bdbaaf1178a5d941c646901e282d2576cce6228963e36aee244fb0c9ba383275fd835bbf99ade67953cd9f7ef3dcffba190c6ff170a2aebfafcec36486edc77a3637e54bacf6c3b6bd5f07aa1fbd45d777b46b6794ffed19dfa6d94474acfee8201d9d40a4a461980e51469971ad5cd651eb1a50a1b3c39a75239561e5d788c8581b558f3d159d3934e54012e68a7229ed90be2d3e47d958a3ff948b74ce20f6d21a2c6cc0a81228b4d26561827767d8237fbabdf5b49055a85b5f7f1ae30616dd98a930e276f16e681952e0c65741ee65bc16b02aa81aa45e4ba05cbb66075a18b0d59f7f6253174db16fe2e9bbddb5909af628ca878bb540327e9030ad3e882952423f0dd0113b76ed923f5b79bb4689786b5495decd02f7f444f844edc2954c3e64c0c72cf758769d86fdc6fe2b288d3cc1ac89b1e02e4065ddb3b75875571914015c4cae7afcbcff893505fc1d4467f2f309900adf1a2d1e7c84af5fda5c3728964c2c98deb99ff0372e1ff2a94cf94850ac22acdafa454ab96e251647ac348a8fa6327f691c88dcff228a2765eced2cb4f10446ad27e9e37cd4854dc73b0f4103f5c31e809878fe8814ef8cdb79611814768e2a1e59f8b5dcf10fd30bb81d08d812ddffd81c2dab906df8dfc4910da71e000e747a68fb59d174425f572304bffacbdd743d65cd5a2be225b744ae252a20fc38a53ac69e2d75e89e179b9ecbf447914c23f9a3a0be0d1b8bd25e0f81458c6846c1ad9bfa42fd23c6d5c9cfadc00f5c37eb4b3c62f1bb04948c202f360e3f7e0a1f46812446684641c1576a0f38c45e6fbd74e4418cf237222299602e267992f18b108cc123a0bdbc8616094c3544d3ca9852133808a32b21e5d032265a409294f8920e22fccf3a281f4ada712388b2b4cc5009c73392f5ac2baa633c379ac7d0e215061e629ae3b947d4ac553c17d75f470c9d4e755ecf28178088b48cb3d657b7ea7ae9db3fddb064754a3a045bdbb0b2eb72da84dd84332d730d450a78a09e25d5186274e75e3f5e78b1d8c447bb3b7d0e202a09f97e15ac1cefa3589f2a0cad5466f74bdfc881002300d1241a7f10f1dec80559a3031892627651a6d9f7414cef66bf42d27a29f194988f3ce9d688ff9777a69fb13702914cb9b2e83f92f921b9f42abcc1f859a36fa00d3959e985cbe0d306636b97adac991363572f110a51860dc129f202209021c7c327a2ac724e97b9ed9f013e45008b5cf50eb379f29ace551332a67b321aab527d4727de634b7416d595a90a881864f8709543549f996f9c1ffd805c16323543b1503a6a3ad97465d45eb4b0b39597bf1d7929d5766b1159e412083c76a943da1604390562be7fdf8d9e1f4276684cf23d975468dbc608419b447252ac6f221b0149ae6fdcb1856e6810854c946176a02476c407fa17f5594bd1cde0bc0bb698e89f5b7de3f015b09b9c64cb29a5748ed5d9e59d25262628dc9e0a57b62a971d61b485f9c7408c16d7caed3597089b6f967f5657205e3a1eb45bae5562ecec5c28c1f075a6afc69bcb95fec55a52a008c6e059abb9cd700c2d8a041cc4fb8749b30430a4ddf259833e96f18782965fd08adea6c4cabe2457b127c5ec569be8429b42004afc81cc9d6d93925dd5ed9f5aaa4881a2fd60f3f8d77125514e643d02094d6204d87e6ed69726e4f3a94170c53c812772b64a1a4f0dab83bf18c4b8def47ba9326966d1f9cd02ca7bf83fd58b4da041d6d146f18bb42d41050f5f802e14128049176f266772050c590536b2aac0eb5d2b50ce36db1df0269a547af4ca68b7950d8df4c354379c9db48b3f8f535e3b4fef4efa05e09986ea5b1075ed3f3d92aa9c1b290db4bbaa0b3eb1ab988608e565876bb40d8d6308899fa2c37bf8a333f44b4eefcd2029931ba443cb8cc656ddc8422c2951cb90640b86f8e0860b70c1c331865cb42457d63fa5522d6166d41ab8f2bb003897607876b8cce247ccfbcd085bebbc510def5b0ccc20dabe5cce83b4b596a8551ce46a7f23a7dd608f37e8b4e4ca2582a7df31ab33a28c812db197ecff7f167807c4768d5ba85b30fda4e0647c615b3366921318760fd350c7d03a4c15e69a4a06ac1a50da6596486978db1c87effe82f6d50bed0f375c5b755f8ed5eeed2bbe3fb50446679c5fa4eb2bdf9f1b6c4b3e5a8f515e93d376bf7e3114b81ae7386ef14ac032747c2e4cdb39eb2aaad2c07d1eb9a14a2a5f3a1e2ade01a585a08d77c23701ddf02585f66da1898a44e737020cafc4ee69ed3ac2858297974b3f18f207823a3859b65a1813fce8b92eb844df81817a20c6684c094d1c4059c2ef259c5a6fe957d3225cd54e252524fd3222be77c435d2f20bfd95986ac439a3dcf4f5e67ee12e05296a9e4d958915ee70463a422be0c876d604d390c14ff14782f8f064e74609b486008f2266db74cdbf139a4cb9513dd2ba6df7a3836ffaa4838ff5edd0bf1c64dd11e6b3cd4bf77483a878fd03468bfec03bae5b6886b8000cd7c39a7f24db5c6393726752a6c4b20243c427536d0e5e83589af9039cf1012f8ee83882d8ba13edf884764b799e3a7829336e63d362c793a4f7345022f4dbb6b8dbfe182cdb6fcc1d242cab766fb698392f1a247484dc1d53e576c78373527c73961bf291431e2efef62ae7ef08dbb050f8ec9f7dd8925f975f29811aa35039b4007de0aa5babfed2cf916afc1f3b5db01446189a53749a86949e25701d827fc8a3cd3ffc789d46c1ee94e137cc960cea364acaf7383c798c8efd57c08bc9a96164782c75523c948478d7ee2b8cdbf2189273e0c6ef8e1d9748e757c028283ddbcc21a507935df36a9f6751e09963c32d86498a14a7ed59f2252cc4b6ed7efb8a06031ecb99be9c3e26378b6cd98bb0811402ddab68b8896904bc86353b4a03f1e865f02ef0a82da843702273eb44454ec171f6207a37a8b81eadf4e894cc95c216038f4f75d23c76ea28f60d20352fafd555372f67c76d3614f5db218c3aa38c39df34376835846d56550fa7158720ab0a72f4350198e169c2b585b42b2acc188da277747b350fda27c84ad803fac8503d6c7558ac0beba55f4ececea3b23dc9eed8a3b916cb0baf99048c88dfff5ecdb00994dbe387c72c8ff955739c04271bde65296ee15c61f1c1c3929fe9fa422c6e8334ac8818f58aaafa1a25058db2e404af42352bd2eac74d3c65295d732b9a17aef1e8c75e7cc6c619c6b2f20383999e22d60ccad360b58d4b877f732c70ebd2ab4d2725c9d0017308d281f3bf193f0a1ed9e4fde3ada9fbea78c95105987dc1c77c27c31eaa31156cfece6a8c53bcda119bbf0f56d019b9ee18267c0c9dcaf32ec15df85d6eb6d7c7cdff948243319188fce2509c3a10ba7a83c85346c96e7882464e2df39dd4a83f2abe45cd6d560213d3b813afd137dee64821e75ca29cd00437a59afe352c2600841ba0e61977c0400f9bf9d37ebca84ba8c0d4699ab6effc5f79a3252ec4713366cbf03c508b2fbceec69fe1c2e5d9ebb5190ff2d5be1908b0772a4253ec613f14bf087a135232d1f2f79676f1f77d85f80ecf62cf25509a6665504656ee6d57f68249a8774e86fa6e16b90af79f31cd57a96d0f00c7e7917a1118af3d4aca325e1f5233b973295be089aafb3abdb692b1adf64c39035db276516ad0b958655c04226af61be66636c1c198532ba43e97934846a4fac0af029c2d9d56747d4561bce70cdd9c5963200c1a5402723b77ad09c837c3306b62f78522ef69716fc12a002ee0db0a69c13b1aeea204e158d64acbbffc70fe07ff05af02d0d2e6c322825c6df8bc4f51890fc7c188a20116890a6bc45086af21b5b481aa0d9648af2da89b2d5ad1cbb28a1f8969c463c22070302352afd0da66a783ff587a153c74e4eea78bbac11d04147b0c487ae0ef696e1c638a289de532a1ac390b7155d1ca084855c098371e4050eb6d0350d1db9e21eb6d62affda12adc1248a51ce06feedc0298b13b0318612008bf0a3087f4d84221af9c9e726c42d3344eb47c2ff27ac173644654574c4fac6e9bcadf18c1df1e74a759433fd5a506a0add063d006c4767cf266444d0963cef547d27ed3ca74fa645fad909e16bc15b7c69dcfcaa011b5a8322d706c34e1204301ce77bb86433f722b56c5cb35d5302a3fba9b24e61751e3953d31758c09f918b4aba0f9d31edaaefe3251e2ac15801edf784b045f6a12e301d91c695d02250348bedc78ef9026bc3012800c042e26d7df9cdbcf590e8a31874c9c31ad675ab0b940d9adcc458ea767a878d5f0e8ca19a03a6bdc749bced0d2985a4c1f190b7a3871bf1dff9cda343280cfb2da3771e0daa1e1aea99a767f71df037cafd2be94dc1914c1495ec090cd61d46f36d83cf60b7279ed3a8e81a53f386df42e0bf29e243e1920a3d59a56195c575e25690711d1a7b4f8310e9a1e6dfbea5c3ae4f25480fec21c4e2726924990319dffa453dff72b3464279974c5303e3c11b582b19f59c99c902ec149dfb3f3f70b4293b8295f702e649c569dc6ee346f3457d9cc79783d79290ca4411288ea251976564b284250ecd25edf98b528a1760dd4a30b8c04c299570fde40a446505d0ded4fb5ab7ea5979c306168047c025ca178728650b9c82dccf0de48be52225c080aa7e1483a560d43307bee06fdf861a22f1554de00ee29fe435b137bb3673a76137c1e8f4a07047700eec11f5feaa2329b0797ec19e57e564abaf1b47f91ae711ecb81b79bc7993e79f5f6208607f05f65db1367220f6ee917a7433bb82dad2a63a3bceaa76a5299ce710c01e17878788a0ae787edc2b5a58fd58842a330fb04461a6190fbff445a9ee8685ecad873726ac2658d3b4cb7b6bd54e16cf42a748136ca9006e4c9a2c37cb9a6d220eb8047ae0b66ad5cd9acda8ecd023679acfbaa15e1f9ddc8bdaeacb54d866b6911749d6905a8033b8d6677eed0724ed9c083bed3d1c40f34ce9c4973cec58369178c85e357c76546576bcdcc255c161d96f91d017b56f74a78b9c65276362bfd59d420b52ea0d10380ccf1ef914eb167daee8f412ef88ff60fc36e0e6dcd3fafcb91300d9d2b9a3c7e11bd67f314625c489610c666729e0db511e8bd4cb4fbd074033a96b3e0fafcc9c75c46a5dfaee73191d1515eab8bf5fff818dc1e9ace53c0c44e374686271cb2e50bf792ea9b7645f13b1b9734091d52b6dec8e9a8881ad7979212cf063980df8df44db0527baf9e09c240c18fc649ea81bc1d6a8fc60a09a7f8587a2fe73e21f9c7c4f79df0362c93b26271433659e7f13e8cf1625d2f551f213cef9502b3a5d1f6ecae689229759b6fbab2d41da45714ea8cd601887df429f3fda0bd1b83b137bd4acb71698ee437b002e2a1348d1bfe731590b50db1ef549b30ff4a1948b9b8de0651fe3b8439fa1a0214379f66da67850761501b99769ee0f07d4115ad4fa92e4f3ebbaaa2b814beee41d984126d8a72d1b1a96fa6a4f53cb97955dd061b85d9d43d026720832b65ed5269a95246008fe0a271475e132a66010374ac6783132b05d5d37ecd8b8eec06adca1e3e9da77db30c2798a8a958a5b6c7c315e0e42dbf9ba2de9bb29dcec5288c751fd3663bf57d397b3674e2c17e11c8544962726528b8267abcc36f765b6a7df8d4678a7b168dc3ce39dbac0dfaca7d10312b5d471c022c66b42f6c95e6d71d4929a3ebf687dd28e0a85f5922915b4706390e50371bb43bcb2d9fb0f70db27479d66ae3b590733955ea8e6226f5d9a2e483f0518037f165ce1fe114a8deee1b5ee53c984916e0c7fc82d1e5d833d70663b8010ef5465bae8b5e1f7287e6eef65e6a5d17219c12efa69fdcfcfaeb18b1b7dd0e2b1dc67249a2e20b6658c87b22e9c0f7a56ba29847f4704cb5e904bf1d53ed987e53af207ac4705641e627aa1e5cbd7b7242c30c67dd9082addd763bc45cf7f677ea7cc88baf0586feba35ef69f46c0dd0b307c3473d3454b5b8d151b08f4f19fa57e6578920268ad25eec35eae5d6012f4e342320e1ba9adf4a967c7bddbb6ef1398661c4ea549e289372fe2cc8647801dea4498022681ac5747e64be27e86dc1459cc414f260a5458ebdfa287e5b651b09e9ce926881142ad2542eb07eb83ae95b4d311c064f06db9ff8739c5f2f67fccc4475cda4fbb8dfd29bb5309d761fc95eff9ece23db2df8814aa1e57ae7a9d015cb1547a2cf046c702f6b5bef6aed076ff31b02425a2aa501222c381c2213e55099a2950f60eb5bec619db23183f378c7970853ec3bc0dc71e337a2536eeed5b52776548d6fcd253a8e068996659787adc9096275b6c9a6c5a7e1422bfe965baceb030f86cfdf216c7718ed08377ba1ee679716a0843b355ae4d4a0f8cff882c1e6cd24abbcb21b1304e56bb5b0da418aaa5e58c2f0ae0d5c97136ab4e172b446dda7561dd2808d3f79094045b71c08310ee42a17b1311a47cfdf5696190da70e6da59eb50c822f5762406b7a6bc2194585b6bea21756dfa41902e0b0d7d54ab1bff9ebf5a2e4f776aff738978e162c04ea4fef083f15b3b4b44830c41d79fcca5f6b98427e04c9315c3d01720fa2530e573152db12d4d601ae0379591b41254a808b635a37872ab0f42c0488533dc056bbc183b0cc80e7027e19e395743fe90784d74622cbbeb94f81397340c641185426ed87ad121f859c820f0da82908b3302399423447822dd3e284966e1e0226b5fc1f29c096ec26354fb6d788aa6cfd0782b148ee63be8c0ab3e643b3ebb548803194dd956f4ba5250be14b8a85281b0fd5103614dcdc95a621815a89f2890e6cabba390308dcd2d459747332fa27e9097d00d6b59e5f2b99e4be30c5654449cdd0a0edaa8f7c93db983f15d80e506c20c6d5c98300d70894459a5167860292dcb744ca14ba709278e59219ee0afdecb5575a8c78a56af99e90e341d8e973e4b58e8262db436a14e8233e299476adf6194ea6b27f94ebf342bac66d479c0b462681a55858cf11605763f521aeee30c3e8e578e57d474df18c3e0cdbeb1fa012976b6dd7e038c835eac98614c3f210a44329abaaf17fefda3c5b1ece67c355c286b0f02581ee79caf64430ae29d79c2f60579f5ba793cd17dcf66b1bd00a8be3aa01c89e33818c7e1a510618c654211511d5fd88e7f85ec42336c9a0bcd62e13e272d333fd449151118f695963fe9c7582145b731627ac01fbb0a5e88d6f07a9f834e48aee7d4b582d88f8668dd8021ecc831d1ca9b3db962e535e1688cd309bd41c3864d36e1e1eb286b03a169b3fb0d332b1a02533af7e1e06a7df7529abad2aef8af0c8a0621ce10837bf8e1b3346b946f7ec1ee9c85124a989a8732577276e994f9aaaaa8265d25e920c00ddf13219bfe280a8d9c1a105e1c218faf9b451e4b81e7479d3ef89e21f27460de338beb1c52bb280607e14b649b485271a7243ce02c1eeacd93bc5670880d2eb12213f61f5af6df884b787e8583b8d561c3211dd97b5e62c10f9de6d6a7c3e022f93f106240c63ec33330fb2836d8a513f896120b711bcff7676baf91b9fc8b0f6dd26451652e3f6eaab640ee7a9b5ee9217fd13c7fa1f894af7ed11c3a3e12fb9927e5592762806d17d3f05f7965a5604784d3684218024557ee03faeb7067fcb1d6e6ee248678c450c053d4b32b5a51abf1bbf308b2cb0987478e979d762687412f1471342f4c298ea2bb9adbbff3c2e63a123ee0bc3c3f2c8164cf60a84f08a9f59e4519e6e4005835d82dee72a6e5a6f03c16a16a92007d52dfbe502b4439cf454e6e339c0724b4269d7e8f5ad328ac3901e82b6a1a7ecb11c7b52bf631fb7b9846a5847a447cd395e361025c6db9c6872807ecc5d2fee7bc51a75d9a2196286f9ed642a35ce95b69baeaa2869a1027c9fca3770120db0f75f459c4ab861e01979361dc98a73d772f546d75a83e6f9781e6db6c9e552dadf7011f1c6d2e46c27f4a358ba94c2fc307110eac072ce93c23fe5d029007d1a6cbfb1911c2df103d45daeb3cfa9c6fbe0ba4423ee5c95900ec67dbb862bb42da5bd184e92e790d4b3e7d4f6f718c2368f6037956434926c4728232f2a0873416d651b923170c1d20ca54b6358aa29cdf8b62d7e7124c7b5227dc5958e9dc135bd129d6d734d8119c81712dadf86af1a6e7594240738a92ffc94a78beda0226b55594bb6ff4d845bd558810a7aef806e66c212f8696c4cebb95efa6c99b402c4403a52776bb036823cb91cbf02516f4d8e2de901d092cff09a8e85fad5f696bddca6afde8bc3843f975e565e6c1334b66a75bc4583cbb85386d436f67030b5cbfc37625058c0b6c7d530d12612057e9abe24de541171741e4456783994408987ad36392bd6621f9d1a959b519d5592c1e657b35419a40ff972d5e89c85f3b328cf9cc3b0fe7f7abc66b7e7ed39750fbb9871e86e5a710230efd792b197f7d5264c0d59dfab09c3c27251b5f409bb83ba5c0464e1762f6dba304bdcac67aab516e269dd772ff8d0a80b7fac8b313c6279be6043096ad36342794ed4f4e583678a98e932bf294475c30e14862dbc29eeb5eae275aa1084135051679123d36e5953f2203774475bb260c634d8eccf33c0ea62b84059b826909157734acdb4b11c349881c863f36a9cd74cb8e60ca6dedef433b851317d49494b62d8eeac757417ca51464f1868ce39597213d585f9d931cf9a4eb570f61f5d3517a2c7e8f2a90bc05157cf50717ffb32ce558d9ef25524bcf2387dc4c93207c23e60b46edafad52f7f0819d370ee61708ac454b82eba7881bcfe5ab336cf96b6c9e327f0f234cb8c70cfcf09be1ffef730be2e05fd2e3e61ad1871818568d1cf92f315b45cc083f1ef51bad39adebb4615323aee84e867e61081d4392b1db7d7bdcf415312e856b68dc0d1c1afb0835dfa91dff59f8c0de4fa8f1bb3c7bdf2c900a62f43ce1804dd22e516cbeb112394ab260511d350bc545e95fa38bb4a17d3509e12921119c3125734aa15ee0328a4376a8031183eb47f975e698bad4a5adca8d1eae0c93d83264a9a1c5294e8e19f1ea0f3cc27b5dbd15242a868a419ae0d5aab8834751bfcdea8354df1e05a3461d0e41d19c096eb77d8d820b3f4516f44dd9a61b2cb10df10945a91f4acdac7e6ad6c066872a79bfeeb36e1dd5d9e5ab378f7af77e80cdeaf2ee10c69beefef175c0f1aa123b604b3b8231532af3ac9746b5c196ebd4dc7d6ef8d076f435409f44339d6d2750824e912b57d947f3da1071dcde7884abf7ce5cc0246d15d22b879cdc9b68a618a8ffd5f7e33f9ee7f03f54df13838bc55aef81acd316ba437cc9789e9d9ef37bb712473eab5369e9556a4c832390150e6ca0e6cf74913c9d7d7e9d6f56ac462853ffe6274eeda5ed0f54a7e8aa77f828955d53524a2f196d37cd698255315c375bd91bc84e4679738eef28458a72399bb53e0df694708e3695564cea5d1ff0345c667e49d1882251805941b42ae23e7d349194fd2599fd9047633748a86a2b44647f264550a0984863977909021eb7da63fb84c5bee1e9860ba09428b2ac2314d421e054106c49ee93d9f36a94d73e77bffe91248ad8676ca9b70aafd794c69a272c82b227eb8ab1042ea949c1cb13ead82bbf2e945d2514bb8065505b8f5bd82143872e4b49858f5281000b0f8ae3d6931ffb23d70c4c0e8ef4caec1a9dc8035f9900ca7207d6e03bbe647de7ea7fd83f47bbf64de20c73e8c3914a4b270754ed77e06fdc498853a6f4ff0a4754b469ccb0ac242e7141a15e044044a4c800ce6477aac0f3e7db8a358f8cee1c6d7686c65a6de1fe2e54f60871a5d34ca31c88ed64a1f24533e4437762b480dc3f21df1870ca75415d5bcf4fd6cf38822086583cdd07135649c877e4a54b6fbe6caa9100d885fc44655543b17f0c1f20fafb5eb8e60beae37137547f962a898c0ddb4a73504c7683a5af2a29bc0e871f713aa3e95cd763936625ab6e276f5c9363cb643485194ddd73454758367fb7679ff9973524b919dedd7a21866351ff064ac346d55c5a97431e04bb10d8f5ea7bfcef63dbd40f08af544ade9728ad4404f43eea7218a6822e974b29bd07fd71f25291c2163c27ea5517090debf376a7fb71781ee05b7f3becb9c3a4ebdefa45d1e139ee728918ffe82645a5d15dfc1cff55f3dbdbf1c90d31d4b4b64dded66018be9de04c3b7160e847cbf8a9e6f87f9f5069c1c80acf74f87b68dc22b70b0aa409c317ac3f20009700b2365cbe816f66e7a3625640d02c2d28e80c2cc01f027b0466d2e0fb316c72e0ce56572454af16f04ea2af9b8cdac38a2ec0cf0744a1a7256aef2cca12befe43dbedb898a11135e4b73e04c7beb8804512f50d5bee17e05398a61505c3ea959c03c90aff9947a0aa292e2e05e7df98f70eb12bd36c889c455770bb62ba0d9bd8a54d382f33e3f782c2194f0eb19d04fe3a141a41f095328573615a8606da57b5eed77d25c4b2c0f850a98b968a2174538cbc21df7a4478dc3361157f0965abe5c56895603d4f9032a7824f9c2cb163eec41773516b9a5f99915bc238c7d664aee38c540b2da7725615312990b6793209c222e2b41068afa5bcf7e31f8f6bb89d8ccac11a26d1ec74e68ca9a0d31325e266fee6fe86af09f084934679003f2ffd2af38bf8df5b9f8fc5f6a5441d9dc852991ad93d110ebd9d527eb5c1c90404de898816acd447ac02c5a889abeb57f575be49527144c9e96424a2b58858a531de4844988bde19ebe6af42276b2d1aad7867af50113ba274282a84832a21519ba048418e8ab788276951632d471f42c83297c5e3950e6ac91b4f18d698366ada37637b117eec23f10f383f1308d284a5887c45e6a1edd2230696601d6aeeb3e3ae130783aa3a13f175ef3bc500d72735560c9b2b277318143a05e40b700d090bdbb1cd6cb5c8053861d2885132cd405b73f174d7567bff1478bf115360db6858ff2633212b0cf01390c60a70e43cbbf9d4cf07af03cc3e46d745145adb2373ddb13f8dd42f533170d2ce40262fe1933a8c71cc0e9277386d70933cf106140f50d62b93d416dccdc93642cb95b7b6309df24dd0e85622a37550831e0604c03a8fd2604f59e53d85730b63b5cf3ef724f20d6642be629cc415740ba0850f0cc8fe132bcbae09bef56bacf18e5ee282dc84263fa32c5aa0b367acc99468c0eaa5d568e68b78d6fd7c09833b084dc3676d0dc3aecc7a4e1e2208245c0cbbdaf205e09f7d9895f7843a5ffb9c63b596f41b9a80e9f7f7f05dd63357f3e58e3e094267fe2b49f9953ddbf306d3db3d510b653296171df858604bd2b6ecc5e523d161e2443cc9802709ac223bc5d7cd2245fefb037b0fa218f6d65f35870b89b2d480a409fc9f93ed4c301f1612aa0664fd10c3d14051739c62c1a39b7377f2486c26cc777730601c6167d4e5f105bd40d3b4759037b85930b7412ae63bb37df83945813b1311e8e81c4e458f3dfcabf0b99da8924356f7e706ca5257baec69cf834e669bf24efb98bf6934f3a18975e427c00a4a42f985bc41796f4e8b4a51d6904ae1544056b17057b0c6c7a68d756ab7eace32077a3ae6ba0aa236dd2c76de58c9595c1a67b174cc898ac7ae807391348f6621b3fddafbdb4e951e8689699473d013f214885a6caad9979954ad70c7a309d00ecaea14086855337c3eb66d843123914bae0e19857932c829e6dc921fcc23d592fbeed17404ff9832ed180ecc5d4e9256d4f1aaeae346007d5e96872b546d93f68df1248b1b32193cd386498ed89bf757eeec6a84bbabf2703fc75d540c6a9b34c3c8cb2c482483912a177792749e9db9f24b097c9ee36bc8c22e97d05c4369a9a81b0e9bce2d47ea4878c9a3ab2b776e5069a14d9a8826951b88894f8f5022c37f3a49b7b88991ecbf59828c8fea68b78fc1e051fc25c0800a0a96c5a52e2c19fb04cd1395528fcfdcf46cffe56193f23e0d4811c4d53c3d37c6e958e20f4f327a97e4e06d9c49435d21f4f54609d34880f9cafcb6d0c2a88b880fa767622cdfc9c9c86213751bcb340fb5d2491ec7e6c972d478c99337f4ecd013211cfce3063cc5af0485202ba8df540b8a38a49f4944da62bf8b354753c9776d2606818f9d85a32c974a322b20134e9668c3958f60b98d85854bfbf477866ffc5f121c0fa7eaa41d706a29f3a452346b9a98e6f2b00af8070f02452a9d2dc1d8f862a253954b36467e50bf6862ecf2055ba9e74febd409ac1256b03f3120c009c3a3db4691c28d332d189bc922536acbffd73dfc510d2e702683fb6efd1f151bde267dce0f16eb2dd2a2ea6c463faaeb8e664ee602d84f40227c9b33799714165112a863a41d1753e8318dd7622deb5df7faa21412c66dfbcb379b101541cbf43ac2aadcd7e4a03a1634abb94af95e4041644bfb1960f6a86e8afbbcc876fa41aaf9df99717104fb5271ec91091571a536c6336716017679cb1c3974a3eb0d8b47b64484956868c034555290cb1b587b30c44ad1dfb7cb5762a635e86c20ab67d2d1606ad3954dae803ff6ea5164c451051fd8c67681fff7621fb52654fd78b11028ae9a62d3f9817db0f1a16c8e145f2884f49f159ce956013699f0c4fdb438a97d5888e4b88be84fbd0df1849a3e93b91fdfd61b160ec8617425bfd4b9125edc79544eab3fd69342c4e3c06c2d0fe108109c6f9dff76b5eb440d349d61cbf3a93fa6e78b35f1b030e3cc0a9d4ebf3f4c722d1793e8c281f4033afe36a01ffcd763aebab2a56f7b2d2161d365f78057b688d372a68fb80930a8ad9ac5b1ac3fc9d0f88d50fd83b7aa74adc527ada42dce831d25c01e31bb7c98d682863d9b402f3326fc61f90607f11e26c37515d32ee43b1243b1777dd1b14388539bdc587812ffb1051497acdf5318a244247b24c630c755b53e62212b83219d2c64e2cb3489ad40e3a6a2ea6c54f771838469b54edb02ed83ab07038242355c82c2a993d4a0cd6c528b69ea9baa2d95a97e7c5b000a250469ff70600ada6809f1016508ead93699062a432f257f37a10475dd68cfb1c2562dc30cf7c4a5474a969e015196cb141566e8abb18b29782a0b1216a654e802bc51109e301ae562b14a34b7cdb89ed9b9ee716c11596d6cb531eca187b58c84465984a2dc673f322acd31cf47b8198a7dbf65bd4cce0c77edec338c1c7e8a0d812b679e5d7cb3e0206a6588041c54c4aec941d99199fbd280cf9e7e540d613b412686d9cbb4760acb51b57e5b80f62ba933ff66cea11bd4eb8e261480bcdbce0c2a60bbc75175abed86181635062d24f0acb884876ab7dcb6387a583f1d68b044e4187ccf7f54b33cb4d303dae1711d0be2983431aa5835e144a735b9b0d173488ae7d89316a6e21353353ec326c14b3659799cb6f0c6a6625fef7e929d3255d079deaa420c09edd0cdcdc5b6fb942fa191f3a5ea4c44f7247e40e7b75e5bb528fe447b2764f8056af0985af0f02aeb4a511d9623d86806baadcc700a560d2fde210736a64117515564c6cb6605224dfd2a5850cf706666d77ec5d4a2d87be37e88d473c1da3bb1f39d7aa54ce2332bee6f4b3f730b69bdf54183ed2e1cad0c9c651c63c55610cb84b679d2a59583fec60bbf0c03639b7b72d3f38f6919e049d2e9333ad7aeb14b8ee45bf72701f676c97ab8ec167ac857dd29443e40e5ba8c213d8e4894bc14b11397afd733d9c5a1e178c3ee254371d99a642b38bec7a237607b383414b8678cf9ff9ee140d09ea55ec84fb997882dc101f5411a1c3e67e5e945bd6b93fd84c102c41f5d18bbea1dc3b06d64389275f9c3ef2084cd1361f8d7c2ce1974f77ecc1809d8a9e58c6cc26f6ffaaeff7ec9c52402ab5694aa02b5e638af2ccddefca4e680fab4bd561ba0f78dcca0ce4785d4578faf3d62ac69bf53c1c874dbfbaf873bb9b6c6c78685b60950d7ea788d0ee3c44a1bf02a7005f36e85a605f28b5e0eb0037c0e474b4dec1fd40af4edc781bb11466fb067d25e04f023152cf8b66e3183251dfab8d51eecc2804d2961918acc91ac56cec95a952ca21220d725df731efb9adbd03550a6187cb28a48c9bde3254055c7a799cfb8926732525dbe67802a1ef5d6b2df14b72e24be63d8d1b6efb3812c723ad7681fc5a6de2666a2c8904ba6fe3c3a7787a34daf9293f0b413ba93f7c22da8264dc95a159bd9d4c76fc64dc897eb5fca07aef201fb931ce4a0b09f46e112eb2360ef5dd02f200f4476751efa48d8a9b317a3d4d4e5448f33d9c0eb1a40621f7843ec699bb44b5b1348d96762a34c01272d983b043e9f4e3d1b6f7c814af9d7a55c47fd77de9602299f2676747f01c31ded0d014d736e91220bb197a537093c3285e0ab91e74360abb519e0d3516d2f32af7ff5e5eb81b05c116d979cd32d33c06264fd5a85442a672b1e4b9feb2f62b72afbf7191e3bc4c827cde00a7743484ee2ebd48bfdab2e2448eaeaceffbefc3ed14eef9fd90a58e8ca0bf70c200a78ba3c5caed76922cfbd20691dd131e20e870003432b38c43a1ac06270717e00746e3524f5e1dfc131137ea98e21086ea675e87fff4cdbf667ff74110275df3c6827e265069a52d1b7e8bbb514b8d55dea9738876c68c41d08e5ab2e54885e4a13cdbd5e45a86088b1076358b101140fc084137a4b39238721fd5dfad9449fe025109ab91d9a56c19f38a3e5277d54e4372c0a4902a7f2f6ee992e2986f0e9dddded68e76e159944e68e0c760f723f6a028cb3018220ab4b7f5843a76114a4d68bd49f04c12d32f70918086b11eaab40b49ac158f99de450a869cfe02b4465aeadd2e2443cd24d1be33d2301a8f0cc8fa5ae745fc84467bfb22f3a0b1146a343ed2c63130a3a45869f2e09cb3b9d4ab07c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">此文章密码为域名哦~</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">此文章来自于群友自述，从懵懂无知到身经百战···</summary>
    
    
    
    <category term="奇奇怪怪" scheme="https://wjldarling.top/categories/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA/"/>
    
    
    <category term="奇奇怪怪" scheme="https://wjldarling.top/tags/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="https://wjldarling.top/posts/3a42db2d.html"/>
    <id>https://wjldarling.top/posts/3a42db2d.html</id>
    <published>2023-06-01T13:19:00.000Z</published>
    <updated>2023-06-01T13:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue3">Vue3</h2><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h3 id="1-Vue3-简介">1.Vue3 简介</h3><ul><li>2020 年 9 月 18 日，Vue.js 发布 3.0 版本，代号：One Piece（海贼王）</li><li>耗时 2 年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个 RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次 PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99 位贡献者</a></li><li>github 上的 tags 地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h3 id="2-Vue3-带来了什么">2.Vue3 带来了什么</h3><h4 id="1-性能的提升">1.性能的提升</h4><ul><li><p>打包大小减少 41%</p></li><li><p>初次渲染快 55%, 更新渲染快 133%</p></li><li><p>内存减少 54%</p><p>…</p></li></ul><h4 id="2-源码的升级">2.源码的升级</h4><ul><li><p>使用 Proxy 代替 defineProperty 实现响应式</p></li><li><p>重写虚拟 DOM 的实现和 Tree-Shaking</p><p>…</p></li></ul><h4 id="3-拥抱-TypeScript">3.拥抱 TypeScript</h4><ul><li>Vue3 可以更好的支持 TypeScript</li></ul><h4 id="4-新的特性">4.新的特性</h4><ol><li><p>Composition API（组合 API）</p><ul><li>setup 配置</li><li>ref 与 reactive</li><li>watch 与 watchEffect</li><li>provide 与 inject</li><li>…</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment</li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除 keyCode 支持作为 v-on 的修饰符</li><li>…</li></ul></li></ol><h2 id="一、创建-Vue3-0-工程">一、创建 Vue3.0 工程</h2><h3 id="1-使用-vue-cli-创建">1.使用 vue-cli 创建</h3><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h3 id="2-使用-vite-创建">2.使用 vite 创建</h3><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite 官网：<a href="https://vitejs.cn">https://vitejs.cn</a></p><ul><li>什么是 vite？—— 新一代前端构建工具。</li><li>优势如下：<ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul></li><li>传统构建 与 vite 构建对比图</li></ul><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/10.webp" style="height:240px;"/><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/11.webp" style="height:240px;"/><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="二、常用-Composition-API">二、常用 Composition API</h2><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h3 id="1-拉开序幕的-setup">1.拉开序幕的 setup</h3><ol><li>理解：Vue3.0 中一个新的配置项，值为一个函数。</li><li>setup 是所有<strong style="color:#DD5145">Composition API（组合 API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在 setup 中。</li><li>setup 函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与 Vue2.x 配置混用<ul><li>Vue2.x 配置（data、methods、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup 中的属性、方法。</li><li>但在 setup 中<strong style="color:#DD5145">不能访问到</strong>Vue2.x 配置（data、methods、computed…）。</li><li>如果有重名, setup 优先。</li></ul></li><li>setup 不能是一个 async 函数，因为返回值不再是 return 的对象, 而是 promise, 模板看不到 return 对象中的属性。（后期也可以返回一个 Promise 实例，但需要 Suspense 和异步组件的配合）</li></ol></li></ol><h3 id="2-ref-函数">2.ref 函数</h3><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code><ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference 对象，简称 ref 对象）</strong>。</li><li>JS 中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了 Vue3.0 中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h3 id="3-reactive-函数">3.reactive 函数</h3><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy 的实例对象，简称 proxy 对象）</strong></li><li>reactive 定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h3 id="4-Vue3-0-中的响应式原理">4.Vue3.0 中的响应式原理</h3><h4 id="vue2-x-的响应式">vue2.x 的响应式</h4><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&quot;count&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h4 id="Vue3-0-的响应式">Vue3.0 的响应式</h4><ul><li>实现原理:<ul><li>通过 Proxy（代理）: 拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。</li><li>通过 Reflect（反射）: 对源对象的属性进行操作。<ul><li><p>MDN 文档中描述的 Proxy 与 Reflect：</p><ul><li>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li><li>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取属性值</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截删除属性</span></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&quot;tom&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="5-reactive-对比-ref">5.reactive 对比 ref</h3><ul><li>从定义数据角度对比：<ul><li>ref 用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li>reactive 用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li>备注：ref 也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li>ref 通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li>reactive 通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li>ref 定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li>reactive 定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h3 id="6-setup-的两个注意点">6.setup 的两个注意点</h3><ul><li>setup 执行的时机<ul><li>在 beforeCreate 之前执行一次，this 是 undefined。</li></ul></li><li>setup 的参数<ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在 props 配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h3 id="7-计算属性与监视">7.计算属性与监视</h3><h4 id="1-computed-函数">1.computed 函数</h4><ul><li><p>与 Vue2.x 中 computed 配置功能一致</p></li><li><p>写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-watch-函数">2.watch 函数</h4><ul><li><p>与 Vue2.x 中 watch 配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视 reactive 定义的响应式数据时：oldValue 无法正确获取、强制开启了深度监视（deep 配置失效）。</li><li>监视 reactive 定义的响应式数据中某个属性时：deep 配置有效。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  sum,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum, msg], <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sum或msg变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  person,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">false</span> &#125;</span><br><span class="line">); <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> person.<span class="property">job</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  [<span class="function">() =&gt;</span> person.<span class="property">job</span>, <span class="function">() =&gt;</span> person.<span class="property">name</span>],</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> person.<span class="property">job</span>,</span><br><span class="line">  <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person的job变化了&quot;</span>, newValue, oldValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">); <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-watchEffect-函数">3.watchEffect 函数</h4><ul><li><p>watch 的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect 的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect 有点像 computed：</p><ul><li>但 computed 注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而 watchEffect 更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> x1 = sum.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">const</span> x2 = person.<span class="property">age</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;watchEffect配置的回调执行了&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-生命周期">8.生命周期</h3><div style="display:flex">  <div>    <strong>vue2.x的生命周期</strong>    <img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/12.webp"  style="zoom:33%;width:1200px" />  </div>  <div>    <strong>vue3.0的生命周期</strong>    <img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/13.webp"  style="zoom:33%;width:2500px" />  </div></div><ul><li>Vue3.0 中可以继续使用 Vue2.x 中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0 也提供了 Composition API 形式的生命周期钩子，与 Vue2.x 中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h3 id="9-自定义-hook-函数">9.自定义 hook 函数</h3><ul><li><p>什么是 hook？—— 本质是一个函数，把 setup 函数中使用的 Composition API 进行了封装。</p></li><li><p>类似于 vue2.x 中的 mixin。</p></li><li><p>自定义 hook 的优势: 复用代码, 让 setup 中的逻辑更清楚易懂。</p></li></ul><h3 id="10-toRef">10.toRef</h3><ul><li><p>作用：创建一个 ref 对象，其 value 值指向另一个对象中的某个属性。</p></li><li><p>语法：<code>const name = toRef(person,'name')</code></p></li><li><p>应用: 要将响应式对象中的某个属性单独提供给外部使用时。</p></li><li><p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p></li></ul><h2 id="三、其它-Composition-API">三、其它 Composition API</h2><h3 id="1-shallowReactive-与-shallowRef">1.shallowReactive 与 shallowRef</h3><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h3 id="2-readonly-与-shallowReadonly">2.readonly 与 shallowReadonly</h3><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h3 id="3-toRaw-与-markRaw">3.toRaw 与 markRaw</h3><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h3 id="4-customRef">4.customRef</h3><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; /&gt;</span><br><span class="line">  &lt;h3&gt;&#123;&#123; keyword &#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, customRef &#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Demo&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">    //自定义一个myRef</span><br><span class="line">    function myRef(value, delay) &#123;</span><br><span class="line">      let timer;</span><br><span class="line">      //通过customRef去实现自定义</span><br><span class="line">      return customRef((track, trigger) =&gt; &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          get() &#123;</span><br><span class="line">            track(); //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">            return value;</span><br><span class="line">          &#125;,</span><br><span class="line">          set(newValue) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(() =&gt; &#123;</span><br><span class="line">              value = newValue;</span><br><span class="line">              trigger(); //告诉Vue去更新界面</span><br><span class="line">            &#125;, delay);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    let keyword = myRef(&quot;hello&quot;, 500); //使用程序员自定义的ref</span><br><span class="line">    return &#123;</span><br><span class="line">      keyword,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-provide-与-inject">5.provide 与 inject</h3><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="6-响应式数据的判断">6.响应式数据的判断</h3><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h2 id="四、Composition-API-的优势">四、Composition API 的优势</h2><h3 id="1-Options-API-存在的问题">1.Options API 存在的问题</h3><p>使用传统 OptionsAPI 中，新增或者修改一个需求，就需要分别在 data，methods，computed 里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h3 id="2-Composition-API-的优势">2.Composition API 的优势</h3><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h2 id="五、新的组件">五、新的组件</h2><h3 id="1-Fragment">1.Fragment</h3><ul><li>在 Vue2 中: 组件必须有一个根标签</li><li>在 Vue3 中: 组件可以没有根标签, 内部会将多个标签包含在一个 Fragment 虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h3 id="2-Teleport">2.Teleport</h3><ul><li><p>什么是 Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件 html 结构</strong>移动到指定位置的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Suspense">3.Suspense</h3><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/Child.vue&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">    &lt;Suspense&gt;</span><br><span class="line">      &lt;template v-slot:default&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-slot:fallback&gt;</span><br><span class="line">        &lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="六、其他">六、其他</h2><h3 id="1-全局-API-的转移">1.全局 API 的转移</h3><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0 中对这些 API 做出了调整：</p><ul><li><p>将全局的 API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h3 id="2-其他改变">2.其他改变</h3><ul><li><p>data 选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x 写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x 写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode 作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  emits: [&quot;close&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p>…</p></li></ul>]]></content>
    
    
    <summary type="html">Vue3学习过程中的笔记</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
    <category term="vue" scheme="https://wjldarling.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://wjldarling.top/posts/54b11a0c.html"/>
    <id>https://wjldarling.top/posts/54b11a0c.html</id>
    <published>2023-06-01T11:57:00.000Z</published>
    <updated>2023-06-01T11:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Promise</h1><h2 id="Promise-的理解和使用">Promise 的理解和使用</h2><h3 id="Promise-是什么">Promise 是什么?</h3><p><strong>抽象表达:</strong></p><ol><li><p>Promise 是一门新的技术(ES6 规范)</p></li><li><p>Promise 是 JS 中进行异步编程的新解决方案</p></li></ol><p>​ 备注：旧方案是单纯使用回调函数</p><p><strong>具体表达:</strong></p><ol><li><p>从语法上来说: Promise 是一个构造函数</p></li><li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值</p></li></ol><h4 id="promise-的状态改变">promise 的状态改变</h4><ol><li><p>pending 变为 resolved</p></li><li><p>pending 变为 rejected</p><p>说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></li></ol><h4 id="promise-的基本流程">promise 的基本流程</h4><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/2.webp"  style="zoom:67%;" /><h4 id="promise-的基本使用">promise 的基本使用</h4><ol><li>使用 1: 基本编码流程</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// 1) 创建 promise 对象(pending 状态), 指定执行器函数 const p = new</span></span><br><span class="line">  <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 2) 在执行器函数中启动异步任务</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="comment">// 3) 根据结果做不同处理</span></span><br><span class="line">      <span class="comment">// 3.1) 如果成功了, 调用 resolve(), 指定成功的 value, 变为 resolved 状态</span></span><br><span class="line">      <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;成功的值 &quot;</span> + time);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3.2) 如果失败了, 调用 reject(), 指定失败的 reason, 变为rejected 状态</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;失败的值&quot;</span> + time);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ) <span class="comment">// 4) 能 promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason p.then(</span></span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功的 value: &quot;</span>, value)</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span>&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败的 reason: &quot;</span>, reason)</span><br><span class="line">  &#125;</span><br><span class="line">  )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 2: 使用 promise 封装基于定时器的异步</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doDelay</span>(<span class="params">time</span>) &#123;</span><br><span class="line"><span class="comment">// 1. 创建 promise 对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 2. 启动异步任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line"><span class="keyword">if</span> (time %<span class="number">2</span>=== <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line"><span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line"><span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, time)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">doDelay</span>(<span class="number">2000</span>)</span><br><span class="line">promise.<span class="title function_">then</span>(</span><br><span class="line"><span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 3: 使用 promise 封装 ajax 异步请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.<span class="property">readyState</span>!==<span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> &#123;status, response&#125; = xhr</span><br><span class="line"><span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line"><span class="keyword">if</span> (status&gt;=<span class="number">200</span> &amp;&amp; status&lt;<span class="number">300</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(response))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line"><span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">xhr.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">promiseAjax</span>(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=video&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line"><span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="为什么要用-Promise">为什么要用 Promise?</h3><h4 id="指定回调函数的方式更加灵活">指定回调函数的方式更加灵活</h4><ol><li>旧的: 必须在启动异步任务前指定</li><li>promise: 启动异步任务 =&gt; 返回 promie 对象 =&gt; 给 promise 对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</li></ol><h4 id="支持链式调用-可以解决回调地狱问题">支持链式调用, 可以解决回调地狱问题*</h4><ol><li><p>什么是回调地狱?</p><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p></li><li><p>回调地狱的缺点?</p><p>不便于阅读 不便于异常处理</p></li><li><p>解决方案?</p><p>promise 链式调用</p></li><li><p>终极解决方案?</p><p>async/await</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 成功的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;声音文件创建成功: &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 失败的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;声音文件创建失败: &quot;</span> + error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.1 使用纯回调函数 */</span></span><br><span class="line"><span class="title function_">createAudioFileAsync</span>(audioSettings, successCallback, failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.2. 使用 Promise */</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">createAudioFileAsync</span>(audioSettings); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">promise.<span class="title function_">then</span>(successCallback, failureCallback);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.1. 回调地狱*/</span></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line"><span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.2. 使用 promise 的链式调用解决回调地狱*/</span></span><br><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.3. async/await: 回调地狱的终极解决方案*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>()</span><br><span class="line"><span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result)</span><br><span class="line"><span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="title function_">failureCallback</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="如何使用-Promise">如何使用 Promise?</h3><h4 id="API">API</h4><ol><li><p>Promise 构造函数: Promise (excutor) {}</p><p>(1) executor 函数: 执行器 (resolve, reject) =&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {}</p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {}</p><p>说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行</p></li><li><p>Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</p><p>(1) onResolved 函数: 成功的回调函数 (value) =&gt; {}</p><p>(2) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></li><li><p>Promise.prototype.catch 方法: (onRejected) =&gt; {}</p><p>(1) onRejected 函数: 失败的回调函数 (reason) =&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p></li><li><p>Promise.resolve 方法: (value) =&gt; {}</p><p>(1) value: 成功的数据或 promise 对象</p><p>说明: 返回一个成功/失败的 promise 对象</p></li><li><p>Promise.reject 方法: (reason) =&gt; {}</p><p>(1) reason: 失败的原因</p><p>说明: 返回一个失败的 promise 对象</p></li><li><p>Promise.all 方法: (promises) =&gt; {}</p><p>(1) promises: 包含 n 个 promise 的数组</p><p>说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就 直接失败</p></li><li><p>Promise.race 方法: (promises) =&gt; {}</p><p>(1) promises: 包含 n 个 promise 的数组</p><p>说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p></li></ol><h4 id="promise-的几个关键问题">promise 的几个关键问题</h4><ol><li><p>如何改变 promise 的状态?</p><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved</p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected</p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></li><li><p>一个 promise 指定多个成功/失败回调函数, 都会调用吗?</p><p>当 promise 改变为对应状态时都会调用</p></li><li><p>改变 promise 状态和指定回调函数谁先谁后?</p><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p><p>(2) 如何先改状态再指定回调?</p><p>​ ① 在执行器中直接调用 resolve()/reject()</p><p>​ ② 延迟更长时间才调用 then()</p><p>(3) 什么时候才能得到数据?</p><p>​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</p><p>​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p></li><li><p>promise.then()返回的新 promise 的结果状态由什么决定?</p><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定</p><p>(2) 详细表达:</p><p>​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</p><p>​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p><p>​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p></li><li><p>promise 如何串连多个操作任务?</p><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</p><p>(2) 通过 then 的链式调用串连多个同步/异步任务</p></li><li><p>promise 异常传透?</p><p>(1) 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,</p><p>(2) 前面任何操作出了异常, 都会传到最后失败的回调中处理</p></li><li><p>中断 promise 链?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</p><p>(2) 办法: 在回调函数中返回一个 pendding 状态的 promise 对象</p></li></ol>]]></content>
    
    
    <summary type="html">Promise</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
    <category term="promise" scheme="https://wjldarling.top/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="https://wjldarling.top/posts/cc1b9611.html"/>
    <id>https://wjldarling.top/posts/cc1b9611.html</id>
    <published>2023-06-01T11:54:00.000Z</published>
    <updated>2023-06-01T11:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>JavaScript</h1><h2 id="常用-API-合集">常用 API 合集</h2><h3 id="节点">节点</h3><h4 id="节点属性">节点属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Node</span>.<span class="property">nodeName</span>; <span class="comment">//返回节点名称，只读</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">nodeType</span>; <span class="comment">//返回节点类型的常数值，只读</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">nodeValue</span>; <span class="comment">//返回Text或Comment节点的文本值，只读</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">textContent</span>; <span class="comment">//返回当前节点和它的所有后代节点的文本内容，可读写</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">baseURI</span>; <span class="comment">//返回当前网页的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">ownerDocument</span>; <span class="comment">//返回当前节点所在的顶层文档对象，即document</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">nextSibling</span>; <span class="comment">//返回紧跟在当前节点后面的第一个兄弟节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">previousSibling</span>; <span class="comment">//返回当前节点前面的、距离最近的一个兄弟节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">parentNode</span>; <span class="comment">//返回当前节点的父节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">parentElement</span>; <span class="comment">//返回当前节点的父Element节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">childNodes</span>; <span class="comment">//返回当前节点的所有子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">firstChild</span>; <span class="comment">//返回当前节点的第一个子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">lastChild</span>; <span class="comment">//返回当前节点的最后一个子节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parentNode接口</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">children</span>; <span class="comment">//返回指定节点的所有Element子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">firstElementChild</span>; <span class="comment">//返回当前节点的第一个Element子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">lastElementChild</span>; <span class="comment">//返回当前节点的最后一个Element子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="property">childElementCount</span>; <span class="comment">//返回当前节点所有Element子节点的数目。</span></span><br></pre></td></tr></table></figure><h4 id="操作">操作</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Node</span>.<span class="title function_">appendChild</span>(node); <span class="comment">//向节点添加最后一个子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">hasChildNodes</span>(); <span class="comment">//返回布尔值，表示当前节点是否有子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">cloneNode</span>(<span class="literal">true</span>); <span class="comment">// 默认为false(克隆节点), true(克隆节点及其属性，以及后代)</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">insertBefore</span>(newNode, oldNode); <span class="comment">// 在指定子节点之前插入新的子节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">removeChild</span>(node); <span class="comment">//删除节点，在要删除节点的父节点上操作</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">replaceChild</span>(newChild, oldChild); <span class="comment">//替换节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">contains</span>(node); <span class="comment">//返回一个布尔值，表示参数节点是否为当前节点的后代节点。</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">compareDocumentPosition</span>(node); <span class="comment">//返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">isEqualNode</span>(node); <span class="comment">//返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">normalize</span>(); <span class="comment">//用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ChildNode接口</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">remove</span>(); <span class="comment">//用于删除当前节点</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">before</span>(); <span class="comment">//在 node 前面 插入节点或字符串</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">after</span>(); <span class="comment">//在 node 后面 插入节点或字符串</span></span><br><span class="line"><span class="title class_">Node</span>.<span class="title function_">replaceWith</span>(); <span class="comment">//将 node 替换为给定的节点或字符串</span></span><br></pre></td></tr></table></figure><h4 id="Document-节点">Document 节点</h4><p><strong>Document 节点的属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">doctype</span>; <span class="comment">//返回 HTML 文档的文档类型对象</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>; <span class="comment">//返回当前文档的根节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">defaultView</span>; <span class="comment">//返回document对象所在的window对象</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>; <span class="comment">//返回当前文档的&lt;body&gt;节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>; <span class="comment">//返回当前文档的&lt;head&gt;节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">activeElement</span>; <span class="comment">//返回当前文档中获得焦点的那个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//节点集合属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">links</span>; <span class="comment">//返回当前文档的所有a元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>; <span class="comment">//返回页面中所有表单元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>; <span class="comment">//返回页面中所有图片元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">embeds</span>; <span class="comment">//返回网页中所有嵌入对象</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">scripts</span>; <span class="comment">//返回当前文档的所有脚本</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">styleSheets</span>; <span class="comment">//返回当前网页的所有样式表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文档信息属性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentURI</span>; <span class="comment">//表示当前文档的网址</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">URL</span>; <span class="comment">//返回当前文档的网址</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span>; <span class="comment">//返回当前文档的域名</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">lastModified</span>; <span class="comment">//返回当前文档最后修改的时间戳</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">location</span>; <span class="comment">//返回location对象，提供当前文档的URL信息</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">referrer</span>; <span class="comment">//返回当前文档的访问来源</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span>; <span class="comment">//返回当前文档的标题</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">characterSet</span>; <span class="comment">//属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">readyState</span>; <span class="comment">//返回当前文档的状态</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">designMode</span>; <span class="comment">//控制当前文档是否可编辑，可读写</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">compatMode</span>; <span class="comment">//返回浏览器处理文档的模式</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>; <span class="comment">//用来操作Cookie</span></span><br></pre></td></tr></table></figure><p><strong>Document 节点的方法</strong></p><p><strong>（1）读写方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">open</span>(); <span class="comment">//用于新建并打开一个文档</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">close</span>(); <span class="comment">//用于关闭一个由 document.open 方法打开的输出流，并显示选定的数据</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(); <span class="comment">//用于向当前文档写入内容</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">writeIn</span>(); <span class="comment">//用于向当前文档写入内容，尾部添加换行符。</span></span><br></pre></td></tr></table></figure><p><strong>（2）查找节点</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selectors); <span class="comment">//接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selectors); <span class="comment">//接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(tagName); <span class="comment">//返回所有指定HTML标签的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(className); <span class="comment">//返回包括了所有class名字符合指定条件的元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(name); <span class="comment">//用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id); <span class="comment">//返回匹配指定id属性的元素节点。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">elementFromPoint</span>(x, y); <span class="comment">//返回位于页面指定位置最上层的Element子节点。</span></span><br></pre></td></tr></table></figure><p><strong>（3）生成节点</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createElement</span>(tagName); <span class="comment">//用来生成HTML元素节点。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text); <span class="comment">//用来生成文本节点</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(name); <span class="comment">//生成一个新的属性对象节点，并返回它。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>(); <span class="comment">//生成一个DocumentFragment对象</span></span><br></pre></td></tr></table></figure><p><strong>（4）事件方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">createEvent</span>(type); <span class="comment">//生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(type, listener, capture); <span class="comment">//注册事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(type, listener, capture); <span class="comment">//注销事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(event); <span class="comment">//触发事件</span></span><br></pre></td></tr></table></figure><p><strong>（5）其他</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">hasFocus</span>(); <span class="comment">//返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">adoptNode</span>(externalNode); <span class="comment">//将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。</span></span><br><span class="line"><span class="variable language_">document</span>.importNode(externalNode, deep); <span class="comment">//从外部文档拷贝指定节点，插入当前文档。</span></span><br></pre></td></tr></table></figure><h4 id="Element-节点">Element 节点</h4><p><strong>Element 节点的属性</strong></p><p><strong>（1）特性属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property">attributes</span>; <span class="comment">//返回当前元素节点的所有属性节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">id</span>; <span class="comment">//返回指定元素的id属性，可读写</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">tagName</span>; <span class="comment">//返回指定元素的大写标签名</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">innerHTML</span>; <span class="comment">//返回该元素包含的HTML代码，可读写</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">outerHTML</span>; <span class="comment">//返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">className</span>; <span class="comment">//返回当前元素的class属性，可读写</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">classList</span>; <span class="comment">//返回当前元素节点的所有class集合</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">dataset</span>; <span class="comment">//返回元素节点中所有的data-*属性。</span></span><br></pre></td></tr></table></figure><p><strong>（2）尺寸属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property">clientHeight</span>; <span class="comment">//返回元素节点可见部分的高度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">clientWidth</span>; <span class="comment">//返回元素节点可见部分的宽度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">clientLeft</span>; <span class="comment">//返回元素节点左边框的宽度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">clientTop</span>; <span class="comment">//返回元素节点顶部边框的宽度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">scrollHeight</span>; <span class="comment">//返回元素节点的总高度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">scrollWidth</span>; <span class="comment">//返回元素节点的总宽度</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">scrollLeft</span>; <span class="comment">//返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">scrollTop</span>; <span class="comment">//返回元素节点的垂直滚动向下滚动的像素数值</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">offsetHeight</span>; <span class="comment">//返回元素的垂直高度(包含border,padding)</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">offsetWidth</span>; <span class="comment">//返回元素的水平宽度(包含border,padding)</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">offsetLeft</span>; <span class="comment">//返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">offsetTop</span>; <span class="comment">//返回水平位移</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">style</span>; <span class="comment">//返回元素节点的行内样式</span></span><br></pre></td></tr></table></figure><p><strong>（3）节点相关属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="property">children</span>; <span class="comment">//包括当前元素节点的所有子元素</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">childElementCount</span>; <span class="comment">//返回当前元素节点包含的子HTML元素节点的个数</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">firstElementChild</span>; <span class="comment">//返回当前节点的第一个Element子节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">lastElementChild</span>; <span class="comment">//返回当前节点的最后一个Element子节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">nextElementSibling</span>; <span class="comment">//返回当前元素节点的下一个兄弟HTML元素节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">previousElementSibling</span>; <span class="comment">//返回当前元素节点的前一个兄弟HTML节点</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="property">offsetParent</span>; <span class="comment">//返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。</span></span><br></pre></td></tr></table></figure><p><strong>Element 节点的方法</strong></p><p><strong>（1）位置方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="comment">// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height</span></span><br><span class="line"><span class="comment">// width、height 元素自身宽高</span></span><br><span class="line"><span class="comment">// top 元素上外边界距窗口最上面的距离</span></span><br><span class="line"><span class="comment">// right 元素右外边界距窗口左边的距离</span></span><br><span class="line"><span class="comment">// bottom 元素下外边界距窗口最上面的距离</span></span><br><span class="line"><span class="comment">// left 元素左外边界距窗口左边的距离</span></span><br><span class="line"><span class="comment">// width 元素自身宽(包含border,padding)</span></span><br><span class="line"><span class="comment">// height 元素自身高(包含border,padding)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">getClientRects</span>(); <span class="comment">//返回当前元素在页面上形参的所有矩形。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素在页面上的偏移量</span></span><br><span class="line"><span class="keyword">var</span> rect = el.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">top</span>: rect.<span class="property">top</span> + <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>,</span><br><span class="line">  <span class="attr">left</span>: rect.<span class="property">left</span> + <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollLeft</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>（2）属性方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="title function_">getAttribute</span>()：读取指定属性</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">setAttribute</span>()：设置指定属性</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">hasAttribute</span>()：返回一个布尔值，表示当前元素节点是否有指定的属性</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">removeAttribute</span>()：移除指定属性</span><br></pre></td></tr></table></figure><p><strong>（3）查找方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="title function_">querySelector</span>();</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">querySelectorAll</span>();</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getElementsByTagName</span>();</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">getElementsByClassName</span>();</span><br></pre></td></tr></table></figure><p><strong>（4）事件方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="title function_">addEventListener</span>(); <span class="comment">//添加事件的回调函数</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">removeEventListener</span>(); <span class="comment">//移除事件监听函数</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">dispatchEvent</span>(); <span class="comment">//触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event对象</span></span><br><span class="line"><span class="keyword">var</span> event = <span class="variable language_">window</span>.<span class="property">event</span> || event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件的目标节点</span></span><br><span class="line"><span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件代理</span></span><br><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span>.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&quot;li&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>（5）其他</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Element</span>.<span class="title function_">scrollIntoView</span>(); <span class="comment">//滚动当前元素，进入浏览器的可见区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>(where, htmlString);</span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeBegin&quot;</span>, htmlString); <span class="comment">// 在该元素前插入</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterBegin&quot;</span>, htmlString); <span class="comment">// 在该元素第一个子元素前插入</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeEnd&quot;</span>, htmlString); <span class="comment">// 在该元素最后一个子元素后面插入</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterEnd&quot;</span>, htmlString); <span class="comment">// 在该元素后插入</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">remove</span>(); <span class="comment">//用于将当前元素节点从DOM中移除</span></span><br><span class="line"><span class="title class_">Element</span>.<span class="title function_">focus</span>(); <span class="comment">//用于将当前页面的焦点，转移到指定元素上</span></span><br></pre></td></tr></table></figure><h3 id="CSS-操作">CSS 操作</h3><p><strong>（1）类名操作</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否有某个类名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasClass</span>(<span class="params">element, className</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(className, <span class="string">&quot;gi&quot;</span>).<span class="title function_">test</span>(element.<span class="property">className</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除class</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeClass</span>(<span class="params">element, className</span>) &#123;</span><br><span class="line">  element.<span class="property">className</span> = element.<span class="property">className</span>.<span class="title function_">replace</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|\\b)&quot;</span> + className.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;|&quot;</span>) + <span class="string">&quot;(\\b|$)&quot;</span>, <span class="string">&quot;gi&quot;</span>),</span><br><span class="line">    <span class="string">&quot;&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）style 操作</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">element.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">element.<span class="property">style</span>.<span class="property">cssText</span>; <span class="comment">//用来读写或删除整个style属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CSS模块的侦测</span></span><br><span class="line">element.<span class="property">style</span>.<span class="title function_">setProperty</span>(propertyName, value); <span class="comment">//设置css属性</span></span><br><span class="line">element.<span class="property">style</span>.<span class="title function_">getPropertyValue</span>(property); <span class="comment">//获取css属性</span></span><br><span class="line">element.<span class="property">style</span>.<span class="title function_">removeProperty</span>(property); <span class="comment">//删除css属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作非内联样式</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(); <span class="comment">//接受一个DOM节点对象作为参数，返回一个包含该节点最终样式信息的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伪类</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(el, <span class="string">&quot;:after&quot;</span>)[attrName];</span><br><span class="line"></span><br><span class="line"><span class="comment">//伪元素</span></span><br><span class="line"><span class="comment">//StyleSheet对象  https://www.jianshu.com/p/09a27917e70e</span></span><br></pre></td></tr></table></figure><h3 id="对象">对象</h3><h4 id="Object-对象">Object 对象</h4><p><strong>（1）生成实例对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//返回原型对象</span></span><br></pre></td></tr></table></figure><p><strong>（3）方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(o); <span class="comment">//遍历对象的可枚举属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyName</span>(o); <span class="comment">//遍历对象不可枚举的属性</span></span><br></pre></td></tr></table></figure><p>对象实例的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">valueOf</span>(); <span class="comment">//返回当前对象对应的值。</span></span><br><span class="line"><span class="title function_">toString</span>(); <span class="comment">//返回当前对象对应的字符串形式。</span></span><br><span class="line"><span class="title function_">toLocaleString</span>(); <span class="comment">//返回当前对象对应的本地字符串形式。</span></span><br><span class="line"><span class="title function_">hasOwnProperty</span>(); <span class="comment">//判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</span></span><br><span class="line"><span class="title function_">isPrototypeOf</span>(); <span class="comment">//判断当前对象是否为另一个对象的原型。</span></span><br><span class="line"><span class="title function_">propertyIsEnumerable</span>(); <span class="comment">//判断某个属性是否可枚举。</span></span><br></pre></td></tr></table></figure><h4 id="Array对象"><strong>Array</strong>对象</h4><p><strong>（1）生成实例对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">length</span>; <span class="comment">//长度</span></span><br></pre></td></tr></table></figure><p><strong>（3）Array.isArray()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(a); <span class="comment">//用来判断一个值是否为数组</span></span><br></pre></td></tr></table></figure><p><strong>（4）Array 实例的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">valueof</span>()   <span class="comment">//返回数组本身</span></span><br><span class="line">a.<span class="title function_">toString</span>()  <span class="comment">//返回数组的字符串形式</span></span><br><span class="line">a.<span class="title function_">push</span>(value,vlaue....)   <span class="comment">//用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span></span><br><span class="line"><span class="title function_">pop</span>()   <span class="comment">//用于删除数组的最后一个元素，并返回该元素</span></span><br><span class="line"><span class="title function_">join</span>()  <span class="comment">//以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</span></span><br><span class="line"><span class="title function_">concat</span>()  <span class="comment">//用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。</span></span><br><span class="line"><span class="title function_">shift</span>()  <span class="comment">//用于删除数组的第一个元素，并返回该元素。</span></span><br><span class="line"><span class="title function_">unshift</span>(value)  <span class="comment">//用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span></span><br><span class="line"><span class="title function_">reverse</span>()   <span class="comment">//用于颠倒数组中元素的顺序，返回改变后的数组</span></span><br><span class="line"><span class="title function_">slice</span>(start_index, upto_index);   <span class="comment">//用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。</span></span><br><span class="line"><span class="title function_">splice</span>(index, count_to_remove, addElement1, addElement2, ...);   <span class="comment">//用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</span></span><br><span class="line"><span class="title function_">sort</span>()   <span class="comment">//对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</span></span><br><span class="line"><span class="title function_">map</span>()   <span class="comment">//对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</span></span><br><span class="line"><span class="title function_">map</span>(elem,index,arr)   <span class="comment">//map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</span></span><br><span class="line"><span class="title function_">forEach</span>()   <span class="comment">//遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。</span></span><br><span class="line"><span class="title function_">filter</span>()   <span class="comment">//参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</span></span><br><span class="line"><span class="title function_">some</span>()    <span class="comment">//用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</span></span><br><span class="line"><span class="title function_">every</span>()   <span class="comment">//用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</span></span><br><span class="line"><span class="title function_">reduce</span>()   <span class="comment">//依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）</span></span><br><span class="line"><span class="title function_">reduceRight</span>()  <span class="comment">//依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）</span></span><br><span class="line"><span class="title function_">indexOf</span>(s)   <span class="comment">//返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span></span><br><span class="line"><span class="title function_">lastIndexOf</span>()  <span class="comment">//返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span></span><br></pre></td></tr></table></figure><h4 id="Number-对象">Number 对象</h4><p><strong>（1）生成对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）Number 对象的属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">POSITIVE_INFINITY</span>; <span class="comment">//正的无限，指向Infinity。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">NEGATIVE_INFINITY</span>; <span class="comment">//负的无限，指向-Infinity。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">NaN</span>; <span class="comment">//表示非数值，指向NaN。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">//表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>; <span class="comment">//表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>; <span class="comment">//表示能够精确表示的最大整数，即9007199254740991。</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span>; <span class="comment">//表示能够精确表示的最小整数，即-9007199254740991。</span></span><br></pre></td></tr></table></figure><p><strong>（4）Number 对象实例的方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">toString</span>(); <span class="comment">//用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</span></span><br><span class="line"><span class="title function_">toFixed</span>(); <span class="comment">//用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</span></span><br><span class="line"><span class="title function_">toExponential</span>(); <span class="comment">//用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。</span></span><br><span class="line"><span class="title function_">toPrecision</span>(); <span class="comment">//用于将一个数转为指定位数的有效数字。</span></span><br></pre></td></tr></table></figure><h4 id="String-对象">String 对象</h4><p><strong>（1）生成实例对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="title class_">String</span>();</span><br></pre></td></tr></table></figure><p><strong>（2）String 对象的属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="property">length</span>; <span class="comment">//返回字符串的长度</span></span><br></pre></td></tr></table></figure><p><strong>（3）方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">chatAt</span>(index); <span class="comment">//返回指定位置的字符</span></span><br><span class="line">s.<span class="title function_">fromCharCode</span>(); <span class="comment">//该方法的参数是一系列Unicode码点，返回对应的字符串。</span></span><br><span class="line">s.<span class="title function_">charCodeAt</span>(index); <span class="comment">//返回给定位置字符的Unicode码点（十进制表示）</span></span><br><span class="line">s.<span class="title function_">concat</span>(s2); <span class="comment">//用于连接两个字符串</span></span><br><span class="line">s.<span class="title function_">slice</span>(start, end); <span class="comment">//用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span></span><br><span class="line">s.<span class="title function_">substring</span>(start, end); <span class="comment">//用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。</span></span><br><span class="line">s.<span class="title function_">substr</span>(start, length); <span class="comment">//用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span></span><br><span class="line">s.<span class="title function_">indexOf</span>(s); <span class="comment">//返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span></span><br><span class="line">s.<span class="title function_">lastIndexOf</span>(); <span class="comment">//返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。</span></span><br><span class="line">s.<span class="title function_">trim</span>(); <span class="comment">//用于去除字符串两端的空格，返回一个新字符串</span></span><br><span class="line">s.<span class="title function_">toLowerCase</span>(); <span class="comment">//用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。</span></span><br><span class="line">s.<span class="title function_">toUpperCase</span>(); <span class="comment">//全部转为大写</span></span><br><span class="line">s.<span class="title function_">localeCompare</span>(s2); <span class="comment">//用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span></span><br><span class="line">s.<span class="title function_">match</span>(regexp); <span class="comment">//用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span></span><br><span class="line">s.<span class="title function_">search</span>(); <span class="comment">//返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span></span><br><span class="line">s.<span class="title function_">replace</span>(oldValue, newValue); <span class="comment">//用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span></span><br><span class="line">s.<span class="title function_">split</span>(); <span class="comment">//按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</span></span><br></pre></td></tr></table></figure><h4 id="Math-对象">Math 对象</h4><p><strong>（1）属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">E</span>; <span class="comment">//常数e。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN2</span>; <span class="comment">//2的自然对数。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LN10</span>; <span class="comment">//10的自然对数。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LOG2E</span>; <span class="comment">//以2为底的e的对数。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">LOG10E</span>; <span class="comment">//以10为底的e的对数。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span>; <span class="comment">//常数Pi。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT1_2</span>; <span class="comment">//0.5的平方根。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">SQRT2</span>; <span class="comment">//2的平方根。</span></span><br></pre></td></tr></table></figure><p><strong>（2）数学方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>()<span class="comment">//返回参数的绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>()<span class="comment">//向上取整，接受一个参数，返回大于该参数的最小整数。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>()<span class="comment">//向下取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(n,n1,...)<span class="comment">//可接受多个参数，返回最大值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(n,n1,..)<span class="comment">//可接受多个参数，返回最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(n,e)<span class="comment">//指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>()<span class="comment">//返回参数值的平方根。如果参数是一个负值，则返回NaN。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>()<span class="comment">//返回以e为底的自然对数值。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">exp</span>()<span class="comment">//返回e的指数，也就是常数e的参数次方。</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>()<span class="comment">//四舍五入</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>()<span class="comment">//返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</span></span><br></pre></td></tr></table></figure><p><strong>（3）三角函数方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">sin</span>(); <span class="comment">//返回参数的正弦</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">cos</span>(); <span class="comment">//返回参数的余弦</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">tan</span>(); <span class="comment">//返回参数的正切</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">asin</span>(); <span class="comment">//返回参数的反正弦（弧度值）</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">acos</span>(); <span class="comment">//返回参数的反余弦（弧度值）</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">atan</span>(); <span class="comment">//返回参数的反正切（弧度值）</span></span><br></pre></td></tr></table></figure><h4 id="JSON-对象">JSON 对象</h4><p><strong>（1）方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>();</span><br><span class="line"><span class="comment">//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。</span></span><br><span class="line"><span class="comment">//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</span></span><br><span class="line"><span class="comment">//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(); <span class="comment">//用于将JSON字符串转化成对象。</span></span><br></pre></td></tr></table></figure><h4 id="console-对象">console 对象</h4><p><strong>（1）方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text,text2,...)   <span class="comment">//用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>()   <span class="comment">//在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">debug</span>()  <span class="comment">//在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">warn</span>()  <span class="comment">//输出信息时，在最前面加一个黄色三角，表示警告；</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>()  <span class="comment">//输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>()  <span class="comment">//可以将复合类型的数据转为表格显示。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">count</span>()  <span class="comment">//用于计数，输出它被调用了多少次。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>()    <span class="comment">//用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dirxml</span>()  <span class="comment">//用于以目录树的形式，显示DOM节点。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>()  <span class="comment">//接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这两个方法用于计时，可以算出一个操作所花费的准确时间。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">time</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">timeEnd</span>()</span><br><span class="line"><span class="comment">//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">profile</span>()  <span class="comment">//用来新建一个性能测试器（profile），它的参数是性能测试器的名字。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">profileEnd</span>()  <span class="comment">//用来结束正在运行的性能测试器。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupend</span>()</span><br><span class="line"><span class="comment">//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupCollapsed</span>()  <span class="comment">//用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">trace</span>()  <span class="comment">//显示当前执行的代码在堆栈中的调用路径。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">clear</span>()  <span class="comment">//用于清除当前控制台的所有输出，将光标回置到第一行。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Js复习笔记</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Vue2</title>
    <link href="https://wjldarling.top/posts/f8e09374.html"/>
    <id>https://wjldarling.top/posts/f8e09374.html</id>
    <published>2023-05-31T21:20:00.000Z</published>
    <updated>2023-05-31T21:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Vue</h1><hr><h3 id="Vue-渐进式理解"><a href="https://blog.csdn.net/wangzunkuan/article/details/80729683">Vue 渐进式理解</a></h3><h3 id="Vue-render-函数"><a href="https://www.jianshu.com/p/7508d2a114d3">Vue render 函数</a></h3><h3 id="vue-diff-算法"><a href="https://www.bilibili.com/video/BV1JR4y1R7Ln/?spm_id_from=333.788&amp;vd_source=e754d95b996bf636e1256b88397221dd">vue diff 算法</a></h3><h2 id="Vue-核心">Vue 核心</h2><h3 id="初识-Vue"><strong>初识 Vue</strong></h3><p>1.想让 Vue 工作,就必须创建一个 Vue 实例,且要传入一个配置对象;</p><p>2.root 容器里的代码依然符合 html 规范，只不过混入了一些特殊的 Vue 语法;</p><p>3.root 容器里的代码被称为【Vue 模板】;</p><p>4.Vue 实例和容器是一一对应的;</p><p>5.真实开发中只有一个 Vue 实例，并且会配合着组件一起使用;</p><p>6.<code>&#123;&#123;xxx&#125;&#125;</code>中的 xxx 要写 js 表达式，且 xxx 可以自动读取到 data 中的所有属性;</p><p>7.一旦 data 中的数据发生改变，那么页面中用到该数据的地方也会自动更新;</p><h3 id="模板语法"><strong>模板语法</strong></h3><p>1.插值语法:<br>功能:用于解析标签体内容。<br>写法:<code>&#123;&#123;xxx&#125;&#125;</code>，xxx 是 js 表达式，且可以直接读取到 data 中的所有属性。</p><p>2.指令语涛<br>功能:用于解析标签（包括:际签属性、标签体内容、绑定事件…)<br>举例: v-bind:href=&quot;xxx”或简写为:href=“xxx”，xxx 同样要写 js 表达式,<br>且可以直接读取到 data 中的所有属性。<br>备注: Vue 中有很多的指令，且形式都是:v-???，此处拿 v-bind 举个例子。</p><hr><h3 id="数据绑定">数据绑定</h3><p>单向数据绑定 (v-bind)</p><ol><li><p>语法：v-bind:href =“xxx” 或简写为 :href</p></li><li><p>特点：数据只能从 data 流向页面</p></li></ol><p>双向数据绑定 (v-model)</p><ol><li>语法：v-mode:value=“xxx” 或简写为 v-model=“xxx”</li><li>特点：数据不仅能从 data 流向页面，还能从页面流向 data</li></ol><p><strong>备注</strong>:</p><ol><li><p>双向绑定一般都应用在表单类元素上(如: input、select 等)</p></li><li><p>v-model :value 可以简写为 v-model，因为 v-model 默认收集的就是 value 值。</p></li></ol><hr><h3 id="el-与-data-的两种写法">el 与 data 的两种写法</h3><p>1.el 有 2 种写法<br>(1). new Vue 时候配置 el 属性。<br>(2). 先创建 Vue 实例，随后再通过 vm.$mount( ‘#root’)指定 el 的值。<br>2.data 有 2 种写法<br>(1).对象式 (2).函数式</p><p><strong>3.一个重要的原则:</strong><br>由 Vue 管理的函数，一定不要写箭头函数，一旦写了箭头函数，this 就不再是 Vue 实例了。</p><hr><h3 id="MVVM-模型">MVVM 模型</h3><ol><li>M：模型(Model) ：对应 data 中的数据</li><li>V：视图(View) ：模板</li><li>VM：视图模型(ViewModel) ： Vue 实例对象</li></ol><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/3.webp"  style="zoom:67%;" /><p>data 中所有的属性,最后都出现在了 vm 身上。<br>vm 身上所有的属性及 Vue 原型上所有属性，在 Vue 模板中都可以直接使用。</p><p><strong>MVVM 的核心</strong>是 ViewModel 层面 他就像是一个中转站 负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上的与视图进行双向绑定 向下与 Model 层通过接口请求请求进行数据交互，起承上启下作用。View 层展现的不是 Model 的数据，而是 ViewModel 层的数 由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。</p><h4 id="Object-defineProperty-方法">Object.defineProperty 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">18</span></span><br><span class="line">    <span class="keyword">let</span> person = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// value: 18,</span></span><br><span class="line">        <span class="comment">// enumerable: true,   //控制属性是否可以枚举，默认值是false</span></span><br><span class="line">        <span class="comment">// writable: true,     //控制属性是否可以被修改，默认值是false</span></span><br><span class="line">        <span class="comment">// configurable: true   //控制属性是否可以被删除，默认值是false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有人修改person的age属性时，set函数(setter)就会被调用，且会受到修改的具体值</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">            number = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="vue-双向绑定原理及实现"><a href="https://www.cnblogs.com/canfoo/p/6891868.html">vue 双向绑定原理及实现</a>*</h4><hr><h3 id="数据代理">数据代理</h3><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=13&amp;spm_id_from=pageDriver&amp;vd_source=e754d95b996bf636e1256b88397221dd">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=13&amp;spm_id_from=pageDriver&amp;vd_source=e754d95b996bf636e1256b88397221dd</a></p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/4.webp"  style="zoom: 50%;" /><p>1.Vue 中的数据代理:<br>通过 vm 对象来代理 data 对象中属性的操作(读/写）</p><p>2.Vue 中数据代理的好处:<br>更加方便的操作 data 中的数据</p><p>3.基本原理:<br>通过 object.defineProperty()把 data 对象中所有属性添加到 vm 上.为每一个添加到 vm 上的属性，都指定一个 getter/setter。<br>在 getter/setter 内部去操作（读/写)data 中对应的属性。</p><hr><h3 id="事件处理">事件处理</h3><h4 id="事件的基本使用">事件的基本使用</h4><p>1.使用 v-on:xxx 或@xxx 绑定事件，其中 xxx 是事件名;</p><p>2.事件的回调需要配置在 methods 对象中，最终会在 vm 上;</p><p>3.methods 中配置的函数，不要用箭头函数! 否则 this 就不是 vm 了;</p><p>4.methods 中配置的函数，都是被 Vue 所管理的函数，this 的指向是 vm 或 组件实例对象;</p><p>5.@click=&quot;demo”和@click=&quot;demo($event)”效果一致，但后者可以传参;</p><h4 id="事件修饰符">事件修饰符</h4><p>1.prevent: 阻止默认事件（常用）;</p><p>2.stop: 阻止事件冒泡（常用）;</p><p>3.once: 事件只触发一次（常用）;</p><p>4.capture: 使用事件的捕获模式;</p><p>5.self: 只有 event.target 是当前操作的元素时才触发事件;</p><p>6.passive: 事件的默认行为立即执行，无需等待事件回调执行完毕;</p><h4 id="键盘事件">键盘事件</h4><p>1.Vue 中常用的按键别名:</p><ul><li><p>回车=&gt; enter</p></li><li><p>删除=&gt; delete(捕获“删除”和“退格”键)</p></li><li><p>退出=&gt; esc</p></li><li><p>空格=&gt; space</p></li><li><p>换行=&gt; tab（特殊，必须配合 keydown 使用）</p></li><li><p>上=&gt; up</p></li><li><p>下=&gt; down</p></li><li><p>左=&gt; left</p></li><li><p>右=&gt; right</p><p>2.Vue 未提供别名的按健，可以使用按健原始的 key 值去绑定，但注意要转为 kebab-case(短横线命名)</p><p>3.系统修饰键（用法特殊）:ctrl、alt、 shift、meta</p></li></ul><p>​ (1).配合 keyup 使用:按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p><p>​ (2).配合 keydown 使用:正常触发事件。</p><p>4.也可以使用 keyCode 去指定具体的按键（不推荐)</p><p>5.Vue.config. keyCodes.自定义键名=健码，可以去定制按键别名</p><hr><h3 id="计算属性与监视">计算属性与监视</h3><p>1.定义:要用的属性不存在，要通过已有属性计算得来。</p><p>2.原理:底层借助了 object.defineproperty 方法提供的 getter 和 setter.</p><p>3.get 函数什么时候执行?<br>(1).初次读取时会执行一次。<br>(2).当依赖的数据发生改变时会被再次调用。</p><p>4.优势:与 methods 实现相比，内部有缓存机制（复用），效率更高，调试方便。</p><p>5.备注:<br>(1).计算属性最终会出现在 vm 上，直接读取使用即可。<br>(2).如果计算属性要被修改，那必须写 set 函数去响应修改，且 set 中要引起计算时依赖的数据发生改变。</p><h4 id="监视属性-watch">监视属性 watch</h4><p>1.当被监视的属性变化时,回调函数自动调用，进行相关操作</p><p>2.监视的属性必须存在,才能进行监视 ！！！</p><p>3.监视的两种写法:</p><p>​ (1).new Vue 时传入 watch 配置</p><p>​ (2).通过 vm.$watch 监视</p><h4 id="深度监视">深度监视</h4><p>​ (1).vue 中的 watch 默认不监测对象内部值的改变（一层）。</p><p>​ (2).配置 deep:true 可以监测对象内部值改变（多层）。</p><p>备注:</p><p>​ (1).Vue 自身可以监测对象内部值的改变，但 Vue 提供的 watch 默认不可以！</p><p>​ (2).使用 watch 时根据数据的具体结构，决定是否采用深度监视。</p><h4 id="computed-和-watch-之间的区别">computed 和 watch 之间的区别</h4><p>​ 1.computed 能完成的功能,watch 都可以完成。<br>​ 2.watch 能完成的功能，computed 不一定能完成，例如: watch 可以进行异步操作。</p><p>两个重要的小原则:</p><p>​ 1.所被 Vue 管理的函数，最好写成普通函数，这样 this 的指向才是 vm 或 组件实例对象</p><p>​ 2.所有不被 Vue 所管理的函数（定时器的回调函数、ajax 的回调函数等、Promise 的回调函数)，最好写成箭头函数,这样 this 的指向才是 vm 或组件实例对象。</p><hr><h3 id="绑定样式">绑定样式</h3><h4 id="class-样式">class 样式</h4><p>写法：class=&quot; xxx&quot; xxx 可以是字符串、对象、数组。<br>字符串写法适用于：类名不确定,要动态获取。<br>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。<br>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p><h4 id="style-样式">style 样式</h4><p>:style=“{fontsize: xxx}” 其中 xxx 是动态值。</p><p>:style=“[a,b]” 其中 a、b 是样式对象。</p><hr><h3 id="条件渲染">条件渲染</h3><h4 id="v-if">v-if</h4><p>写法:<br>(1).v-if=“表达式”</p><p>​(2).v-else-if=“表达式”</p><p>​  (3).v-else=“表达式”</p><p>适用于: 切换频率较低的场景。</p><p>特点: 不展示的 DOM 元素直接被移除。</p><p>注意: v-if 可以和: v-else-if、v-else 一起使用，但要求结构不能被“打断”。</p><h4 id="v-show">v-show</h4><p>写法: v-show=“表达式”</p><p>适用于: 切换频率较高的场景。</p><p>特点: 不展示的 DOM 元素未被移除,仅仅是使用样式隐藏掉</p><p><strong>备注</strong>:使用 v-if 的时，元素可能无法获取到，而使用 v-show 一定可以获取到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">&quot;???&quot;</span>&gt;???&lt;/template&gt;</span><br><span class="line"><span class="comment">//template 母版，最终不会渲染到页面上，页面上只会出现中间的内容，template配合v-if使用</span></span><br></pre></td></tr></table></figure><hr><h3 id="列表渲染">列表渲染</h3><h4 id="v-for-指令">v-for 指令</h4><p>1.用于展示列表数据<br>2.语法: v-for=&quot; (item,index) in xxx&quot; :key=“yyy”<br>3.可遍历: 数组、对象、字符串（用的很少）、指定次数（用的很少)</p><h4 id="key-作用与原理">key 作用与原理</h4><p>面试题: react、vue 中的 key 有什么作用?（key 的内部原理)</p><ol><li><p>虚拟 DOM 中 key 的作用:<br>key 是虚拟 DOM 对象的标识，当状态中的数据发生变化时，Vue 会根据【新数据】生成【新的虚拟 DOM】,随后 Vue 进行【新虚拟 DOM】与【旧虚拟 DOM】的差异比较，比较规则如下:</p></li><li><p>对比规则:<br>(1).旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key:<br>若虚拟 DOM 中内容没变，直接使用之前的真实 DOM !<br>若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM。<br>(2).旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key<br>创建新的真实 DOM,随后渲染到到页面。</p></li><li><p>用 index 作为 key 可能会引发的问题:</p><ol><li>若对数据进行: 逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题，但效率低。</li><li>如果结构中还包含输入类的 DOM: 会产生错误 DOM 更新 ==&gt; 界面有问题。</li></ol></li><li><p>开发中如何选择 key? :</p><ol><li>最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值。</li><li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示,使用 index 作为 key 是没有问题的。</li></ol></li></ol><hr><h3 id="监测数据">监测数据</h3><p>1.vue 会监视 data 中所有层次的数据。</p><p>2.如何监测对象中的数据?</p><p>​   通过 setter 实现监视,且要在 new Vue 时就传入要监测的数据。</p><p>​       (1).对象中后追加的属性，Vue 默认不做响应式处理</p><p>​       (2).如需给后添加的属性做响应式，请使用如下 API:</p><p>​           vue.set(target, propertyName/index, value）或</p><p>​           vm.$set(target, propertyName/index, value)</p><p>3.如何监测数组中的数据?</p><p>​   通过包裹数组更新元素的方法实现,本质就是做了两件事:</p><p>​     (1).调用原生对应的方法对数组进行更新。</p><p>​     (2).重新解析模板,进而更新页面。</p><p>4.在 Vue 修改数组中的某个元素一定要用如下方法:</p><p>​   1.使用这些 API: push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>​   2.Vue.set() 或 vm.$set()</p><p><strong>特别注意</strong>: Vue.set(）和 vm.$set()不能给 vm 或 vm 的根数据对象添加属性！！！</p><hr><h3 id="收集表单数据">收集表单数据</h3><p>若:<code>&lt;input type=&quot;text&quot;/&gt;</code>, 则 v-model 收集的是 value 值。用户输入的就是 value 值。</p><p>若:<code>&lt;input type=&quot;radio&quot;/&gt;</code>，则 v-model 收集的是 value 值，且要给标签配置 value 值。</p><p>若:<code>&lt;input type=&quot;checkbox&quot; /&gt;</code></p><p>​ 1.没有配置 input 的 value 属性，那么收集的就是 checked(勾选 or 未勾选，是布尔值)</p><p>​ 2.配置 input 的 value 属性:</p><p>​    (1) v-model 的初始值是非数组，那么收集的就是 checked（勾选 or 未勾选，是布尔值)</p><p>​ (2) v-model 的初始值是数组，那么收集的的就是 value 组成的数组</p><p><strong>备注</strong>: v-model 的三个修饰符:</p><p>​           lazy: 失去焦点再收集数据</p><p>​           number: 输入字符串转为有效的数字</p><p>​           ​trim: 输入首尾空格过滤</p><h3 id="内置指令">内置指令</h3><p>v-bind : 单向绑定解析表达式，可简写为:xxx</p><p>v-model : 双向数据绑定</p><p>v-for : 遍历数组/对象/字符串</p><p>v-on : 绑定事件监听，可简写为@</p><p>v-if : 条件渲染(动态控制节点是否存在)</p><p>v-else : 条件渲染（动态控制节点是否存在)</p><p>v-show : 条件渲染(动态控制节点是否展示)</p><p><strong>v-text 指令</strong>:</p><p>1.作用:向其所在的节点中渲染文本内容。</p><p>2.与插值语法的区别:v-text 会替换掉节点中的内容，则不会。</p><p><strong>v-html 指令</strong>:</p><p>1.作用:向指定节点中渲染包含 html 结构的内容。</p><p>2.与插值语法的区别:</p><p>​ (1).v-html 会替换掉节点中所有的内容，则不会。</p><p>​ (2).v-html 可以识别 html 结构。</p><p>3.严重注意: v-html 有安全性问题！！！</p><p>(1).在网站上动态渲染任意 HTML 是非常危险的，容易导致 XSS 攻击。</p><p>(2).一定要在可信的内容上使用 v-html，永不要用在用户提交的内容上!</p><p><strong>v-cloak 指令</strong>(没有值):</p><p>1.本质是一个特殊属性。Vue 实例创建完毕并按管容器后，会剧掉 v-cloak 属性。</p><p>2.使用 css 配合 v-cloak 可以解决网速慢时页面展示出  的问题。</p><p><strong>v-once 指令</strong>:</p><p>1.v-once 所在节点在初次动态演染后,就视为静态内容了。</p><p>2.以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能。</p><p><strong>v-pre 指令</strong>:</p><p>1.跳过其所在节点的编译过程</p><p>2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编译。</p><hr><h3 id="自定义指令">自定义指令</h3><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/5.webp" style="zoom: 80%;" /><hr><h3 id="生命周期">生命周期</h3><p>1.又名: 生命周期回调函数、生命周期函数、生命周期钩子。</p><p>2.是什么: Vue 在关键时刻帮我们调用的一些特殊名称的函数。</p><p>3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。</p><p>4.生命周期函数中的 this 指向是 vm 或 组件实例对象。</p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/6.webp" alt="生命周期" style="zoom: 20%;" /><p>常用的生命周期钩子:</p><p>1.<strong>mounte</strong>发送 ajax 请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p><p>2.<strong>beforeDestroy</strong>: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p><p>关于销毁 Vue 实例</p><p>1.销毁后借助 Vue 开发者工具看不到任何信息。</p><p>2.销毁后自定义事件会失效，但原生 DOM 事件依然有效。</p><p>3.一般不会再 beforeDestroy 操作数据，因为即便操作数据，也不会再触发更新流程了。</p><h2 id="Vue-组件化编程">Vue 组件化编程</h2><p>Vue 中使用组件的三大步骤:</p><p>​   1. 定义组件(创建组件）</p><p>​   2. 注册组件</p><p>​   3. 使用组件(写组件标签)</p><p>一、如何定义一个组件?</p><p>​ 使用 Vue.extend(options)创建，其中 options 和 new Vue(options)时传入的那个 options 几乎一样，但也有点区别：</p><p>​ 区别如下:</p><p>​ 1.el 不要写，为什么?—最终所有的组件都要经过一个 vm 的管理，由 vm 中的 el 决定服务哪个容器。</p><p>​ 2.data 必须写成函数，为什么?——避免组件被复用时，数据存在引用关系。</p><p>​ <strong>备注</strong>: 使用 template 可以配置组件结构。</p><p>二、如何注册组件?</p><p>1.局部注册: 靠 new Vue 的时候传入 components 选项</p><p>2.全局注册: 靠 Vue.component(‘组件名’,组件)</p><p>三、编写组件标签:<br><code>&lt;school&gt;&lt;/school&gt;</code></p><h3 id="非单文件组件">非单文件组件</h3><p>几个注意点:</p><p>1.关于组件名:<br>一个单词组成:</p><p>​ 第一种写法(首字母小写): school</p><p>​ 第二种写法(首字母大写): School</p><p>​ 多个单词组成:</p><p>​ 第一种写法(kebab-case 命名):my-school</p><p>​ 第二种写法(Camelcase 命名):MySchool（需要 Vue 脚手架支持)</p><p>​ <strong>备注:</strong><br>​ (1).组件名尽可能回避 HTML 中已有的元素名称，例如: h2、H2 都不行。</p><p>​ (2).可以使用 name 配置项指定组件在开发者工具中呈现的名字-</p><p>2.关于组件标签:</p><p>​ 第一种写法:<code>&lt;school&gt;&lt;/school&gt;</code></p><p>​ 第二种写法: <code>&lt;school/&gt;</code></p><p>​ 备注:不用使用脚手架时,<code>&lt;school/&gt;</code>会导致后续组件不能渲染。</p><p>3.一个简写方式:</p><p>​ const school = Vue.extend(options）可简写为: const school = options</p><h4 id="VueComponent">VueComponent</h4><ol><li><p>school 组件本质是一个名为 VueComponent 的构造函数，且不是程序员定义的，是 Vue.extend 生成的.</p></li><li><p>我们只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，Vue 解析时会帮我们创建 school 组件的实例对象，即 vue 帮我们执行的</p><p>new VueComponent(options)</p></li><li><p>特别注意:每次调用 Vue.extend，返回的都是一个全新的 VueComponent ！！！</p></li><li><p>关于 this 指向:</p><p>(1).组件配置中:</p><p>​  data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是【VueComponent 实例对象】</p><p>(2).new Vue() 配置中:</p><p>​  data 函数、methods 中的函数、watch 中的函数、computed 中的函数它们的 this 均是【Vue 实例对象】.</p></li><li><p>VueComponent 的实例对象，以后简称 vc（也可称之为:组件实例对象）。</p><p>Vue 的实例对象,以后简称 vm.</p></li></ol><hr><h4 id="内置关系">*内置关系</h4><p>一个重要的内置关系:</p><p>​ <code>VueComponent.prototype.__proto__ === Vue.prototype</code></p><p>为什么要有这个关系:</p><p>​ 让组件实例对象(vc）可以访问到 Vue 原型上的属性、方法。</p><blockquote><p><strong>实例的隐式原型属性永远指向自己缔造者的原型对象。</strong></p></blockquote><h3 id="单文件组件">单文件组件</h3><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH/?p=60">单文件组件</a></p><h2 id="使用-Vue-脚手架">使用 Vue 脚手架</h2><h3 id="初始化脚手架">初始化脚手架</h3><p><strong>创建脚手架</strong></p><p><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=61&amp;vd_source=e754d95b996bf636e1256b88397221dd">https://www.bilibili.com/video/BV1Zy4y1K7SH?p=61&amp;vd_source=e754d95b996bf636e1256b88397221dd</a></p><h4 id="脚手架文件结构">脚手架文件结构</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules</span><br><span class="line">├── public</span><br><span class="line">│ ├── favicon<span class="selector-class">.ico</span>: 页签图标</span><br><span class="line">│ └── index<span class="selector-class">.html</span>: 主页面</span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">│ ├── assets: 存放静态资源</span><br><span class="line">│ │ └── logo<span class="selector-class">.png</span></span><br><span class="line">│ │── component: 存放组件</span><br><span class="line">│ │ └── HelloWorld<span class="selector-class">.vue</span></span><br><span class="line">│ │── App<span class="selector-class">.vue</span>: 汇总所有组件</span><br><span class="line">│ │── <span class="selector-tag">main</span><span class="selector-class">.js</span>: 入口文件</span><br><span class="line">├── <span class="selector-class">.gitignore</span>: git 版本管制忽略的配置</span><br><span class="line">├── babel<span class="selector-class">.config</span><span class="selector-class">.js</span>: babel 的配置文件</span><br><span class="line">├── package<span class="selector-class">.json</span>: 应用包配置文件</span><br><span class="line">├── README<span class="selector-class">.md</span>: 应用描述文件</span><br><span class="line">├── package-lock.json：包版本控制文件</span><br></pre></td></tr></table></figure><h4 id="关于不同版本的-Vue">关于不同版本的 Vue:</h4><p>1.vue.js vue.runtime.xxx.js 的区别:</p><p>​ (1).vue.js 是完整版的 Vue，包含: 核心功能+模板解析器。<br>​ (2).vue.runtime.xxx,js 是运行版的 Vue， 只包含: 核心功能; 没有模板解析器。</p><p>2.因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</p><h4 id="vue-config-js-配置文件">vue.config.js 配置文件</h4><p>使用<code>vue inspect &gt; output.js</code>可以查看到 Vue 脚手架的默认配置。</p><p>使用 vue.config.js 可以对脚手架进行个性化定制，详情见: <a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></p><h3 id="ref-与-props">ref 与 props</h3><h4 id="ref-属性">ref 属性</h4><p>1.被用来给元素或子组件注册引用信息（id 的替代者)</p><p>2.应用在 htm1 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象(vc)</p><p>3.使用方式:</p><p>​ 打标识: <code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code>或<code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></p><p>​ 获取: <a href="http://this.$refs.xxx">this.$refs.xxx</a></p><h4 id="配置项-props">配置项 props</h4><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/7.webp" style="zoom: 80%;" /><h3 id="父子组件间的三种通信方式">父子组件间的三种通信方式*</h3><h4 id="通过-props-实现通信">通过 props 实现通信</h4><p>子组件的 props 选项能够接收来自父组件的数据。props 是单项绑定的</p><h5 id="props-静态传递">props 静态传递</h5><p>子组件通过 props 选项来声明一个自定义的属性，然后父组件就可以再嵌套标签的时候，通过这个属性往子组件传递数据了！</p><p><strong>father_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">&quot;我是子组件一！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span>  <span class="comment">&lt;!-- 通过自定义属性传递数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_props.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>] <span class="comment">// 声明一个自定义的属性</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h5 id="props-动态传递">props 动态传递</h5><p>更多的时候我们需要传送一个动态的数据。这时候就可以用==v-bind(:)==实现。通过 v-bind 绑定 props 的自定义的属性，传递过去的就不是静态的字符串了，它可以是一个表达式，布尔值，对象等等任何类型的值</p><p><strong>father_props.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">&quot;我是子组件一！&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:message</span>=<span class="string">&quot;a+b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 用一个变量进行动态赋值 --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:message</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_props.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">a</span>: <span class="string">&#x27;我是子组件二！&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">b</span>: <span class="number">41</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">msg</span>: <span class="string">&#x27;我是子组件三！&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">random</span>()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr><p><strong>child_props.vue 子组件不变</strong></p><h4 id="通过-ref-实现通信">通过$ref 实现通信</h4><p>对于 ref 官方的解释是：ref 是被用来给元素或子组件注册引用信息的。引用信息将会注册在父组件的$refs 对象上。</p><p>props 是父组件给子组件信息，那么，$ref 就是子组件给父组件信息。</p><p>简单来说，父组件可以通过$ref 来调用子组件的信息，包括 data 和 methods</p><p><strong>father_ref.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_ref.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">msg</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">msg</span>.<span class="title function_">getMessage</span>(<span class="string">&#x27;我是子组件一！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_ref.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    getMessage (m) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">message</span> = m</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="props-和-ref-的对比">props 和$ref 的对比</h4><p>1.前者着重于数据的传递，它并不能调用子组件里的属性和方法</p><p>2.后者着重于索引，主要用来调用子组件里的属性和方法。特别地，ref 用在 dom 元素的时候，能起到选择器的作用，这个功能比作为索引更加重要</p><hr><h4 id="emit-实现通信">$emit 实现通信</h4><p>上面两种方法主要都是父组件为主，给子组件信息，调用子组件的信息。<br>那么，第三种方法就是以子组件为主。<br>$emit 绑定一个自定义事件 event，当这个语句被执行的时候，就会将参数 arg 传递给父组件，父组件通过@event 监听并接收参数。</p><p><strong>father_emit.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">getMessage</span>=<span class="string">&quot;showMsg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;../components/child_emit.vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title class_">Child</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    showMsg (title) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">this</span>.<span class="property">title</span> = title</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>child_emit.vue</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是子组件！<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mounted</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getMessage&#x27;</span>, <span class="string">&#x27;我是父组件！&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">scoped</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="三种方法区别">三种方法区别</h4><p>1.对于 props，就是子组件设置一个 props，父组件给这个 props 赋值就可以通信，动态赋值可以用 v-bind（是主要的通信方式）</p><p>2.对于 ref，给子组件一个 ref，我们就可以通过这个<code>this.ref</code>，来调用子组件的属性和方法，这主要是用在 dom 树中，起到选择器的作用</p><p>3.对于$emit，子组件绑定一个方法和参数，父组件可以绑定子组件这个绑定方法的监听，获得子组件返回的参数。第三种方法少见一些。有些逆思维了。 目前不懂它存在的意义。</p><h3 id="混入-mixin">混入 mixin</h3><p><strong>解释</strong></p><p>将组件的公共逻辑或者配置提取出来，哪个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余度，也可以让后期维护起来更加容易。</p><p>这里需要注意的是：提取的是逻辑或配置，而不是 HTML 代码和 CSS 代码。换一种想法，mixin 就是组件中的组件，Vue 组件化让我们的代码复用性更高，那么组件与组件之间还有重复部分，我们使用 Mixin 在抽离一遍。</p><h4 id="Mixin-和-Vuex-的区别？">Mixin 和 Vuex 的区别？</h4><p>上面一点说 Mixin 就是一个抽离公共部分的作用。在 Vue 中，Vuex 状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：</p><ul><li>Vuex 公共状态管理，如果在一个组件中更改了 Vuex 中的某个数据，那么其它所有引用了 Vuex 中该数据的组件也会跟着变化。</li><li>Mixin 中的数据和方法都是独立的，组件之间使用后是互相不影响的。</li></ul><p><strong>功能</strong>:可以把个组件共用的配置提取成一个混入对象使用方式:<br>第一步定义混合,例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;...&#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步使用混入,例如:</p><p>​ (1).全局混入: Vue.mixin(xxx)</p><p>​ (2).局部混入: mixins: [‘xxx’]</p><h3 id="插件">插件</h3><p>功能:用于增强 Vue<br>本质:包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p><p>定义插件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue，options</span>) &#123;</span><br><span class="line"><span class="comment">//1.添加全局过滤器</span></span><br><span class="line">vue.<span class="title function_">filter</span>(....)</span><br><span class="line"><span class="comment">//2.添加全局指令</span></span><br><span class="line">vue.<span class="title function_">directive</span>(.. . .)</span><br><span class="line"><span class="comment">//3.配置全局混入(合)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(... .)</span><br><span class="line"><span class="comment">//4.添加实例方法</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;...&#125;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用插件</strong>: <code>Vue.use()</code></p><h4 id="scoped-样式">scoped 样式</h4><p>作用: 让样式在局部生效，防止冲突。</p><p>写法: <code>&lt;style scoped&gt;</code></p><h3 id="TodoList-案例总结">TodoList 案例总结</h3><p>1.组件化编码流程:</p><p>​ (1).拆分静态组件:组件要按照功能点拆分，命名不要与 html 元素冲突。</p><p>​ (2).实现动态组件:考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用:</p><p>   1).一个组件在用: 放在组件自身即可。</p><p>   2).一些组件在用: 放在他们共同的父组件上(<strong>状态提升</strong>)。</p><p>​ (3).实现交互:从绑定事件开始。</p><p>2.props 适用于:</p><p>​ (1).父组件==&gt;子组件 通信</p><p>​ (2).子组件==&gt;父组件 通信(要求父先给子一个函数)</p><p>3.使用 v-model 时要切记: <strong>v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</strong></p><p>4.props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p><h3 id="webStorage">webStorage</h3><p>1.存储内容太小一般支持 5MB 左右(不同浏览器可能还不一样)</p><p>2.浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p><p>3.相关 APl:<br>  1.<code>xxxxxStorage.setItem('key', 'value');</code><br>  该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。<br>  2.<code>xxxxxStorage-getItem('person');</code><br>  该方法接受一个键名作为参数，返回键名对应的值。<br>  3.<code>xxxxxStorage.removeItem('key');</code><br>  该方法接受一个键名作为参数，并把该键名从存储中删除。<br>  4.<code>xxxxxStorage.clear()</code><br>  该方法会清空存储中的所有数据。</p><p>4.<strong>备注</strong>:</p><p>​ 1.SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</p><p>​ 2.LocalStorage 存储的内容，需要手动清除才会消失。</p><p>​ 3.<code>xxxxxStorage.getItem(xxx)</code> 如果 xxx 对应的 value 获取不到，那么 getltem 的返回值是 null</p><p>​ 4.<code>JSON.parse(nul1)</code>的结果依然是 null。</p><h3 id="组件自定义事件">组件自定义事件</h3><p>1.子种组件间通信的方式，适用于:<strong>子组件</strong>===&gt;<strong>父组件</strong></p><p>⒉.使用场景: A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<strong>事件的回调在 A 中</strong>)。</p><p>3.绑定自定义事件:</p><p>​ (1).第一种方式，在父组件中: <code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>或<code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code><br>​ (2).第二种方式，在父组件中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo ref=&quot;demo&quot; /&gt;</span><br><span class="line">...... mounted()&#123; this.$refs.xxx.$on(&#x27;atguigu&#x27;,this.test) &#125;</span><br></pre></td></tr></table></figure><p>​ (3).若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p><p>4.触发自定义事件: <code>this.$emit('atguigu',数据)</code></p><p>5.解绑自定义事件<code>this.$off('atguigu')</code></p><p>6.组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p><p>7.<strong>注意</strong>:通过<code>this.refs.xxx.$on('atguigu' ,回调)</code>绑定自定义事件时，回调<strong>要么配置在 methods 中，要么用箭头函数</strong>，否则 this 指向会出问题！！！</p><h3 id="全局事件总线">全局事件总线</h3><p>1.—种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><p>2.安装全局事件总线:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> / /安装全局事件总线，$bus就是当前应用的vm</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.使用事件总线 :</p><p>​ (1).接收数据: A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<strong>回调留在 A 组件自身</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ (2).提供数据:<code>this.$bus.$emit( 'xxxx',数据)</code></p><p>4.最好在 beforeDestroy 钩子中，用$off 去解绑<strong>当前组件所用到的事件*</strong>。</p><h3 id="消息订阅与发布（pubsub）">消息订阅与发布（pubsub）</h3><p>1.—种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><p>2.使用步骤:</p><p>​ 1.安装 pubsub: <code>npm i pubsub-js</code><br>​ 2.引入: <code>import pubsub from 'pubsub-js'</code><br>​ 3.接收数据:A 组件想接收数据，则在 A 组件中订阅消息，订阅的<strong>回调留在 A 组件自身</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)<span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.提供数据:<code>pubsub.publish('xxx',数据)</code></p><p>5.最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color: red">取消订阅。</span></p><h4 id="nextTick（生命周期钩子）">nextTick（生命周期钩子）</h4><p>1.语法: <code>this.$nextTick(回调函数)</code></p><p>2.作用: 在下一次 DOM 更新结束后执行其指定的回调。</p><p>3.什么时候用: 当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</p><p><a href="https://blog.csdn.net/zhouzuoluo/article/details/84752280">vue.nextTick()方法的使用详解（简单明了）</a></p><h3 id="过渡与动画">过渡与动画</h3><p>1.作用: 在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p><p>2.图示:<br><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/9.webp" /><br>3.写法:</p><p>​ 1.准备好样式:</p><p>​ (1).元素进入的样式:</p><p>​  ​ 1.v-enter: 进入的起点</p><p>​ ​  ​ 2.v-enter-active: 进入过程中</p><p>​  ​ 3.v-enter-to: 进入的终点</p><p>​ (2).元素离开的样式:</p><p>​ ​  ​ 1.v-leave: 离开的起点</p><p>​ ​  ​ 2.v-leave-active: 离开过程中</p><p>​ ​  ​ 3.v-leave-to: 离开的终点</p><p>​ 2.使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>你好啊!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ 3.<strong>备注</strong>: 若有多个元素需要过度，则需要使用:<code>&lt;transition-group&gt;</code>，且每个元素都要指定 key 值。</p><h2 id="Vue-中的-ajax">Vue 中的 ajax</h2><h3 id="vue-脚手架配置代理-开发环境-Ajax-跨域问题">vue 脚手架配置代理(开发环境 Ajax 跨域问题)</h3><p><strong>方法一</strong></p><p>在 vue.config.js 中添加如下配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">proxy</span>: <span class="string">&quot;http://localhost:5000&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:</p><p>​ 1.优点: 配置简单，请求资源时直接发给前端（8080）即可。</p><p>​ 2.缺点: 不能配置多个代理，不能灵活的控制请求是否走代理。</p><p>​ 3.工作方式: 若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源)</p><p><strong>方法二</strong></p><p>编写 vue.config.js 配置具体代理规则:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/api1&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">//匹配所有以&#x27;/api&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">//代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;/api2&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">//匹配所有以&#x27;/api&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&quot;http://localhost: 5001&quot;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">changeOrigin设置为true时，服务器收到的请求头中的host为: localhost: 5000</span></span><br><span class="line"><span class="comment">changeOrigin设置为false时，服务器收到的请求头中的host为: localhost:8080</span></span><br><span class="line"><span class="comment">changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明:</p><p>​ 1.优点: 可以配置多个代理，且可以灵活的控制请求是否走代理。</p><p>​ 2.缺点: 配置略微繁琐，请求资源时必须加前缀。</p><h3 id="slot-插槽">slot 插槽</h3><p>1.作用: 让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于<strong>父组件===&gt;子组件</strong>。</p><p>2.分类: 默认插槽、具名插槽、作用域插槽</p><p>3.使用方式:</p><p>​ (1).默认插槽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--定义插槽--&gt;</span><br><span class="line">    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​</p><p>​ (2).具名插槽:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">&lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template v-slot:footer&gt;</span><br><span class="line">&lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--定义插槽--&gt;</span><br><span class="line">    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>​ (3).作用域插槽:</p><p>​ 1).理解: 数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。(games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p><p>​ 2).具体编码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!--生成的是ul列表--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; : key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!--生成的是h4标题--&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Category&quot;,</span><br><span class="line">  props: [&quot;title&quot;],</span><br><span class="line">  //数据在子组件自身</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      games: [&quot;红色警戒&quot;, &quot;穿越火线&quot;, &quot;英雄联盟&quot;, &quot;超级玛丽&quot;],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="vuex">vuex</h2><h3 id="概念">概念</h3><p>专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方</p><p>式，且适用于任意组件间通信。</p><p><strong>为什么要使用 Vuex</strong></p><p>我们知道组件之间是独立存在的 组件之间要想实现通信 目前只有 props 选项 ，中大型项目时 面对一大堆组件之间的通信，与逻辑代码 将组件之间的共享数据给拿出来 在一定的规则下管理这些数据</p><p><strong>什么时候使用 Vuex？</strong></p><ol><li>多个组件依赖于同一状态</li><li>来自不同组件的行为需要变更同一状态</li></ol><h4 id="vuex-工作原理图">vuex 工作原理图</h4><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/8.webp" alt="vuex" style="zoom: 33%;" /><ul><li><strong>视图（View）</strong>，以声明方式将<strong>状态</strong>映射到视图；</li><li><strong>操作（Actions）</strong>，响应在<strong>视图</strong>上的用户输入导致的状态变化</li><li><strong>状态（State）</strong>，驱动应用的数据源</li></ul><h3 id="搭建-vuex-环境-store">搭建 vuex 环境(store)</h3><p>1.创建文件:<code>src/store/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="comment">//应用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)，</span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="基本使用">基本使用</h3><ol><li>初始化数据、配置<code>actions</code> 、配置<code>mutations</code>，操作文件<code>store.js</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"><span class="comment">//响应组件中加的动作</span></span><br><span class="line">    <span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;actions中的jia被调用了&#x27;,miniStore ,value)</span></span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line"><span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;mutations中的JIA被调用了&#x27; ,state,value)</span></span><br><span class="line">        state.<span class="property">sum</span> += value</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line"><span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">    state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>组件中读取 vuex 中的数据:<code>$store.state.sum</code></p></li><li><p>组件中修改 vuex 中的数据:<code>$store.dispatch('action中的方法名',数据)</code>或<code>$store.commit('mutations中的方法名',数据)</code></p></li></ol><blockquote><p><strong>备注</strong>:若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote><h3 id="getters-的使用">getters 的使用</h3><ol><li><p>概念: 当 state 中的数据需要经过加正后再使用时，可以使用 getters 加工。</p></li><li><p>在<code>store.js </code>中追加<code>getters</code>配置</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>组件中读取数据:<code>$store.getters.bigSum</code></li></ol><h3 id="四个-map-方法的使用">四个 map 方法的使用</h3><p>1.<strong>mapState 方法</strong>: 用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"><span class="comment">//借助mapState生成计算属性: sum、school、subject（对象写法)</span></span><br><span class="line">...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;)，</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapState生成计算属性: sum、school、subject（数组写法)</span></span><br><span class="line">...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>mapGetters 方法</strong>: 用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性: bigSum(对象写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性: bigSum(数组写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>mapActions 方法</strong>: 用于帮助我们生成与<code>actions</code>对话的方法，即:包含<code>$store.dispatch(xx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成: increment0dd、 incrementWait（对象形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jia0dd&#x27;</span>,<span class="attr">incrementwait</span>:<span class="string">&#x27;jiawait&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//靠mapActions生成: incrementOdd、incrementwait（数组形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>([<span class="string">&#x27;jia0dd&#x27;</span>,<span class="string">&#x27;jiawait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.<strong>mapMutations 方法</strong>:用于帮助我们生成与<code>mutations</code>对话的方法，即:包含 <code>$store.commit(xx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成: increment、decrement（对象形式)</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapMutations生成:JIA、JIAN（对象形式)</span></span><br><span class="line">...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>])，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块化-命名空间">模块化+命名空间*</h3><p>1.目的: 让代码更好维护，让多种数据分类更加明确。</p><p>2.修改<code>store.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">    <span class="attr">state</span>:&#123; <span class="attr">x</span>:<span class="number">1</span> &#125;,</span><br><span class="line"><span class="attr">mutations</span>:&#123; ... &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123; ... &#125;，</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">    <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line"><span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">    <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"><span class="attr">modules</span>: &#123;</span><br><span class="line">countAbout,</span><br><span class="line">        personAbout</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.开启命名空间后，组件中读取 state 数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二:借助mapState读取:</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>])，</span><br></pre></td></tr></table></figure><p>4.开启命名空间后，组件中读取 getters 数据:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二:借助mapGetters读取;</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>, [<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure><p>5.开启命名空间后，组件中调用 dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>, person)</span><br><span class="line"><span class="comment">//方式二，借助mapActions:</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>, <span class="attr">incrementwait</span>:<span class="string">&#x27;jiawait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>6.开启命名空间后，组件中调用 commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span> ,person)</span><br><span class="line"><span class="comment">//方式二:借助mapMutations:</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure><h3 id="vuex-核心概念和-API">vuex 核心概念和 API</h3><p>各个类型的 API 各司其职，mutation 只管存，你给我（dispatch）我就存；action 只管中间处理，处理完我就给你，你怎么存我不管；Getter 我只管取，我不改的。action 放在了 methods 里面，说明我们应该把它当成函数来用（讲道理，钩子函数也应该可以的） mutation 是写在 store 里面的，这说明，它就是个半成品，中间量，我们不应该在外面去操作它。getter 写在了 computed 里面，这说明虽然 getter 我们写的是函数，但是我们应该把它当成计算属性来用。</p><h4 id="state">state</h4><p>1.vuex 管理的状态对象</p><p>2.是<strong>Vuex</strong>中的唯一数据源</p><p>3.只能通过 mutation 修改</p><p>4.示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">xxx.<span class="property">initValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="actions">actions</h4><p>1.值为一个对象，包含多个响应用户动作的回调函数</p><p>2.通过 <code>commit()</code>来触发<code> mutation</code> 中函数的调用, 间接更新 state</p><p>3.如何触发 actions 中的回调？</p><p>​ 在组件中使用: <code>$store.dispatch('对应的 action 回调名') </code>触发</p><p>4.可以包含异步代码（定时器, ajax 等等）</p><p>5.示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="title function_">zzz</span>(<span class="params">&#123; commit, state &#125;, data1</span>) &#123;</span><br><span class="line">    <span class="title function_">commit</span>(<span class="string">&quot;yyy&quot;</span>, &#123; data1 &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="mutations">mutations</h4><p>1.值是一个对象，包含多个直接更新 state 的方法</p><p>2.谁能调用 mutations 中的方法?如何调用?</p><p>​ 在 action 中使用: <code>commit('对应的 mutations 方法名')</code>触发</p><p>3.mutations 中方法的特点: 不能写异步代码、只能单纯的操作 state</p><p>4.示例代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">yyy (state，&#123;data1&#125;) &#123;</span><br><span class="line"><span class="comment">//更新state的某个属性</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="modules">modules</h4><p>1.包含多个 module</p><p>2.一个 module 是一个 store 的配置对象</p><p>3.与一个组件（包含有共享数据）对应</p><h4 id="model">model*</h4><p><a href="https://vuex.vuejs.org/zh/guide/modules.html">Module | Vuex (vuejs.org)</a></p><p><a href="https://www.jianshu.com/p/a0c11ae01991">https://www.jianshu.com/p/a0c11ae01991</a></p><h2 id="vue-router">vue-router</h2><h3 id="相关理解">相关理解</h3><h4 id="vue-router-的理解">vue-router 的理解</h4><p>vue 的一个插件库，专门用来实现 SPA 应用</p><h4 id="对-SPA-应用的理解">对 SPA 应用的理解</h4><ol><li>单页 Web 应用（single page web application，SPA）。</li><li>整个应用只有<strong>一个完整的页面</strong>。</li><li>点击页面中的导航链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</li><li>数据需要通过 ajax 请求获取</li></ol><h3 id="基本路由">基本路由</h3><h4 id="路由的理解">路由的理解</h4><ol><li><p>什么是路由?</p><ol><li>一个路由就是 ─ 组映射关系(key - value)</li><li>key 为路径, value 可能是 function 或 component</li></ol></li><li><p>路由分类</p></li><li><p>后端路由:</p><ol><li><p>理解: value 是 function,用于处理客户端提交的请求。</p></li><li><p>工作过程: 服务器接收到一个请求时,根据<strong>请求路径</strong>找到匹配的<strong>函数</strong>来处理请求,返回响应数据。</p></li></ol></li><li><p>前端路由:</p><ol><li><p>理解: value 是 component，用于展示页面内容。</p></li><li><p>工作过程: 当浏览器的路径改变时,对应的组件就会显示。</p></li></ol></li></ol><h4 id="基本使用-2">基本使用</h4><p>1.安装 vue-router，命令:<code>npm i vue-router</code> 如果是 vue2 的话,命令后面加@3</p><p>2.应用插件:<code>Vue.use(VueRouter)</code></p><p>3.编写 router 配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//引入Luyou组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;../components/About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;../ components /Home&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>4.实现切换(active-class 可配置高亮样式)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">About</span></span><br><span class="line">&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>5.指定展示位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="几个注意点">几个注意点</h4><p>1.路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p><p>2.通过切换，“隐藏&quot;了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p><p>3.每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>4.整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</p><h3 id="嵌套路由-多级路由">嵌套路由(多级路由)</h3><p>1.配置路由规则，使用 children 配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">//通过children配置子级路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;news&quot;</span>, <span class="comment">//此处一定不要写:/news</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;message&quot;</span>, <span class="comment">//此处一定不要写:/message</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.跳转（要写完整路径)∶</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">&quot;/home/news&quot;</span>&gt;<span class="title class_">News</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h3 id="路由的-query-参数">路由的 query 参数</h3><p>1.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;! --跳转并携带query参数，to的字符串写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail?id=666&amp;title=你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带query参数，to的对象写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">path:&quot;</span>/<span class="attr">home</span>/<span class="attr">message</span>/<span class="attr">detail</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">query:</span>&#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id:666</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span> &#x27;<span class="attr">你好</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.接收参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure><h3 id="命名路由">命名路由</h3><p>1.作用: 可以简化路由的跳转。</p><p>2.如何使用</p><p>​ 1.给路由命名:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">                <span class="attr">children</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;hello’//给路由命名</span></span><br><span class="line"><span class="string">                        path:&#x27;</span>welcome<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">component:Hello,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>2.简化跳转:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前,需要写完整的路径--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&#x27;/demo/test/welcome&#x27;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name : &quot;</span><span class="attr">hello</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">query:</span>&#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">id</span> <span class="attr">:666</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">title:</span>&#x27;<span class="attr">你好</span>&#x27;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="路由的-params-参数">路由的 params 参数</h3><p>1.配置路由，声明接收 params 参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>,<span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--跳转并携带params参数，to的字符串写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail/666/你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带params参数，to的对象写法--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name:&#x27;xiangqing&#x27;,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">params:&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">id:666,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">title:&quot;</span><span class="attr">你好</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;”</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>特别注意: 路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置!</p></blockquote><p>3.接收参数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span>;</span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span>;</span><br></pre></td></tr></table></figure><h3 id="路由的-props-配置">路由的 props 配置</h3><p>作用: 让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"><span class="comment">//第一种写法: props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">//props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法: props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">//props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法:props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line"><span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue-路由传参的三种基本方式"><a href="https://www.jianshu.com/p/d276dcde6656">vue 路由传参的三种基本方式</a></h4><h3 id="路由传参相关面试题">路由传参相关面试题</h3><p><strong>如何指定 params 参数可传可不传?</strong><br>如果路由要求传递 params 参数，但是你就不传递 params 参数，发现一件事情，URL 会有问题的<br>如何指定 params 参数可以传递、或者不传递，在配置路由的时候，在占位的后面加上一个问号【params 可以传递或者不传递】</p><p><strong>params 参数可以传递也可以不传递，但是如果传递是空串，如何解决?</strong></p><p>使用 undefined 解快: params 参数可以传递、不传递（空的字符串)</p><p><code>this.$router.push(&#123;name:'search' ,params:&#123; keyword : &quot; &quot;||undefined&#125; &#125;),</code></p><p><strong>路由组件可不可以传递 props 数据？</strong></p><p>可以，三种写法，在路由配置中，组件用 props 接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//布尔值写法:params</span></span><br><span class="line"><span class="comment">//props:true,只能传params参数</span></span><br><span class="line"><span class="comment">//对象写法:额外的给路由组件传递一些props</span></span><br><span class="line"><span class="comment">//props:&#123;a: 1,b:2&#125;,</span></span><br><span class="line"><span class="comment">//函数写法:可以params参数、query参数，通过props传递给路由组件</span></span><br><span class="line"><span class="attr">props</span>:<span class="function">(<span class="params">$route</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span>·&#123;<span class="attr">keyword</span>:$route.<span class="property">params</span>.<span class="property">keyword</span> ,<span class="attr">k</span>:$route.<span class="property">query</span>.<span class="property">k</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="router-link-的-replace-属性-无痕浏览-doge"><code>&lt;router-link&gt;</code>的 replace 属性(无痕浏览 doge)</h3><p>1.作用:控制路由跳转时操作浏览器历史记录的模式</p><p>⒉ 浏览器的历史记录有两种写入方式:分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p><p>3.如何开启<code>replace</code>模式:<code>&lt;router-link replace ......&gt;News&lt;/router-link&gt;</code></p><h3 id="编程式路由导航">编程式路由导航</h3><p>1.作用:不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p><p>2.具体编码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiangqing&quot;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>(); <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>(); <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(); <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure><h3 id="缓存路由组件">缓存路由组件</h3><p>1.作用:让不展示的路由组件保持挂载，不被销毁。</p><p>2.具体编码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&quot;News(组件名)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><h3 id="两个新的生命周期钩子">两个新的生命周期钩子</h3><p>1.作用: 路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</p><p>2.具体名字:</p><ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol><h3 id="路由守卫">路由守卫</h3><p>作用: 对路由进行权限控制</p><h4 id="全局守卫">全局守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫:初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&quot;)</span></span><br><span class="line"><span class="string">//next(&#123;name:&#x27;</span>guanyu<span class="string">&#x27;&#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">next()//放行</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//全局后置守卫:初始化时执行、每次路由切换后执行</span></span><br><span class="line"><span class="string">router.afterEach((to,from)=&gt;&#123;</span></span><br><span class="line"><span class="string">if(to.meta.title)&#123;</span></span><br><span class="line"><span class="string">document.title = to.meta.title  //修改网页的title</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">document.title = &#x27;</span>vue_test<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="独享守卫">独享守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">//next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件内路由守卫">组件内路由守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫:通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to,<span class="keyword">from</span>,next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫:通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to,<span class="keyword">from</span>,next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由器的两种工作模式-hash-与-history">路由器的两种工作模式 hash 与 history</h3><p>1.对于一个 url 来说，什么是 hash 值?——#及其后面的内容就是 hash 值。</p><p>2.hash 值不会包含在 HTTP 请求中，即: hash 值不会带给服务器。</p><p>3.hash 模式:</p><p>​ (1).地址中永远带着#号，不美观。</p><p>​ (2).若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</p><p>​ (3).兼容性较好。</p><p>​ (4).他虽然在 URL 中，但是不会被包括在 HTTP 请求当中 对后端完全没影响 因此改变 hash 不会重新加载页面</p><p>4.history 模式:</p><p>​ (1).地址干净，美观。</p><p>​ (2).兼容性和 hash 模式相比略差。</p><p>​ (3).应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</p><p>​ (4).当他修改执行时 虽然改变了当前的 URL 但游览器不会立即向后端发送请求</p><h3 id="前端路由原理解析与实现">前端路由原理解析与实现</h3><p><strong>什么是前端路由 ？</strong></p><p>路由描述的是 URL 与 UI 之间的映射关系 这种映射是单向的 即 URL 变化引起的 UI 更新（无需刷新页面）</p><p><strong>如何实现前端路由？</strong></p><p>要实现前端路由需要解决两个核心</p><p>1.如何改变 URL 却不引起页面刷新</p><p>2.如何检测 URL 变化了</p><p>下面分别使用 hash 与 history 两种实现方式回答上面的两个核心问题</p><p><strong>hash 实现</strong></p><p>hash 是 url 中 hash（#）及后面的部分，常用作锚点在页面进行导航，改变 url 中的 hash 部分不会引起页面刷新</p><p>通过 hashchange 事件 监听 url 变化 改变 url 的方式只有这几种：通过游览器的前进后退 通过标签改变 url 通过 window.location 改变 URL 这几种情况改变 URL 都会触发 hashchange 事件</p><p><strong>history 实现</strong></p><p>history 提供了 pushState（增加状态）和 replaceState（改变状态）两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新</p><p>history 提供类似<code>hashchange</code> 事件的 popstate 事件 但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过<code>pushState/replaceState</code>或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 <code>pushState/replaceState</code>的调用和标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</p><h2 id="Vue-UI-组件库">Vue UI 组件库</h2><h3 id="移动端常用-UI-组件库">移动端常用 UI 组件库</h3><ol><li>Vant <a href="https://youzan.github.io/vant">https://youzan.github.io/vant</a></li><li>Cube UI <a href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a></li><li>Mint UI <a href="http://mint-ui.github.io">http://mint-ui.github.io</a></li></ol><h3 id="PC-端常用-UI-组件库">PC 端常用 UI 组件库</h3><ol><li>Element UI <a href="https://element.eleme.cn">https://element.eleme.cn</a></li><li>IView UI <a href="https://www.iviewui.co">https://www.iviewui.co</a>.</li></ol><h2 id="组件间通信高级">组件间通信高级*</h2><h3 id="1-事件注意事项">1.事件注意事项</h3><p>事件：系统事件：click、双击、鼠标系列事件等等</p><p>​ 自定义事件</p><p>事件源、事件类型、事件回调</p><p>1、原生 DOM----button 标签可以绑定系统事件</p><p>2、组件标签-----可以绑定系统事件（不起作用：因为属于自定义事件）------@click 后面+ .native （可以把自定义事件变成原生的 DOM 事件）</p><p>原生 DOM click 事件，其实是给子组件的根节点绑定了单击事件----利用到事件委派</p><p>给原生 DOM 绑定自定义事件是没有任何意义的，因为没有办法触发$emit 函数</p><h3 id="2-v-model">2.v-model</h3><p>【组件通信方式的一种】</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;深入v-model&lt;/h2&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">    &lt;h2&gt;v-model实现原理（vue2)&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">原生DOw当中是有oninput事件，它经常结合表单元素一起使用，当表单元素文本内容发生变化的时候就会发出发一次回调</span><br><span class="line">Vue2:可以通过value与input事件实现v-model功能</span><br><span class="line">:value 与 oninput 事件结合与 :v-model一样</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=&quot;msg = $event.target.value&quot; /&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;!--深入学习v-model：实现父子组件数据同步（实现父子组件通信） --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:value到底是什么？ props，父子组件通信</span><br><span class="line">@input到底是什么？ 并非原生DOM的input事件，属于自定义事件</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;CustomInput :value=&quot;msg&quot; @input=&quot;msg = $event&quot; /&gt;</span><br><span class="line">    &lt;!-- 简化写法 --&gt;</span><br><span class="line">    &lt;CustomInput v-model=&quot;msg&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &quot; ModelTest&#x27;,</span><br><span class="line">cmponents:&#123;</span><br><span class="line">CustomInput</span><br><span class="line">&#125;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&quot;我爱你塞北的大雪&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>CustomInput 组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;input包装组件&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:value   动态属性</span><br><span class="line">@input   给原生DOM绑定原生DOM事件</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      :value=&quot;value&quot;</span><br><span class="line">      @input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &#x27;CustomInput&#x27;,</span><br><span class="line">props:[&#x27;value&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>v-model 实现原理：value 与 input 事件实现的，而且还需要注意可以通过 v-mode 实现父子组件数据同步</p><h3 id="3-sync-属性修饰符">3.sync 属性修饰符</h3><p>【组件通信方式的一种】</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    小明的爸爸现在有&#123;&#123; money &#125;&#125;元</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;不使用sync修改符&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:money父组件给子组件传递props</span><br><span class="line">@update:money给子组件绑定的自定义事件只不过名字叫做update:money</span><br><span class="line">目前现在这种操作，起始和v-model很相似,可以实现父子组件数据同步</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;Child :money=&quot;money&quot; @update:money=&quot;money = $event&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h2&gt;使用sync修改符&lt;/h2&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">:money.sync:  </span><br><span class="line">第一，父组件给字符串传递props money</span><br><span class="line">第二，给当前子组件绑定了一个自定义事件,而且事件名称即为update:money</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;Child2 :money.sync=&quot;money&quot; /&gt;</span><br><span class="line">    &lt;hr /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">import Child2 from &#x27;./Child2.vue&#x27;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;&#x27;,</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">money : 10000</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">Child,</span><br><span class="line">        Child2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Child 组件（两个组件一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;小明每次花100元&lt;/span&gt;</span><br><span class="line">    &lt;button @click=&quot;$emit(&#x27;update:money&#x27;, money - 100)&quot;&gt;花钱&lt;/button&gt;</span><br><span class="line">    爸爸还剩&#123;&#123; money &#125;&#125;元</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">name:&#x27;child&#x27;,</span><br><span class="line">props: [&#x27;money&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="4-attrs-与-listeners">4. <code>$attrs</code> 与 <code>$listeners</code></h3><p><code>$attrs</code>属于组件的一个属性，可以获取到父组件传递过来的props数据，对于子组件而言，父组件给的数据可以利用props接收，如果子组件通过props接收的属性，在$attrs 属性当中是获取不到的</p><p>$listeners 也是组件实例自身的一个属性，他可以获取到父组件给子组件传递的自定义事件</p><p>按钮想要增加鼠标放上去的提示信息，外面加一个 a 标签，:title 属性为提示信息</p><h3 id="5-children与-parent">5.<code>$children</code>与<code>$parent</code></h3><p>建议用 ref ,直接获取相应的子组件</p><p>$children 是组件实例的属性，可以获取到当前组件的全部子组件【是个数组】</p><p>不要用$children[0]书写，如果子组件过多，第 0 项可能不是想要的组件</p><p>$parent 可以获取到某个组件的父组件，可以操作父组件的数据和方法</p><h3 id="6-混入-mixin">6.混入 mixin</h3><p>如果项目当中出现很多结构类似功能，想到组件复用</p><p>如果项目当中很多的组件 JS 业务逻辑相似，想到 mixin【可以把多个组件 JS 部分重复、相似地方】</p><h3 id="7-插槽">7.插槽</h3><p>可以实现父子组件通信（通信的结构）</p><p>默认插槽</p><p>具名插槽</p><p>作用域插槽：子组件的数据来源于父组件，子组件是决定不了自身结构与外观</p>]]></content>
    
    
    <summary type="html">Vue2学习过程中的笔记</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
    <category term="vue" scheme="https://wjldarling.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Axios</title>
    <link href="https://wjldarling.top/posts/6155a9d6.html"/>
    <id>https://wjldarling.top/posts/6155a9d6.html</id>
    <published>2023-05-31T16:00:00.000Z</published>
    <updated>2023-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Axios</h1><p><a href="https://blog.csdn.net/weixin_44972008/article/details/114368528">【axios】使用 json-server 搭建 REST API - 使用 axios - 自定义 axios - 取消请求 - 拦截器_YK 菌的博客-CSDN 博客</a></p><h2 id="axios-是什么">axios 是什么?</h2><p>前端最流行的 ajax 请求库</p><p>react/vue 官方都推荐使用 axios 发 ajax 请求</p><h2 id="axios-特点">axios 特点</h2><p>1.基于 xhr + promise 的异步 ajax 请求库</p><p>2.浏览器端/node 端都可以使用</p><p>3.支持请求／响应拦截器</p><p>4.支持请求取消</p><p>5.请求/响应数据转换</p><p>6.批量发送多个请求</p><h2 id="axios-常用语法">axios 常用语法</h2><p>axios(config): 通用/最本质的发任意类型请求的方式</p><p>axios(url[, config]): 可以只指定 url 发 get 请求</p><p>axios.request(config): 等同于 axios(config)</p><p>axios.get(url[, config]): 发 get 请求</p><p>axios.delete(url[, config]): 发 delete 请求</p><p>axios.post(url[, data, config]): 发 post 请求</p><p>axios.put(url[, data, config]): 发 put 请求</p><p><a href="http://axios.defaults.xxx">axios.defaults.xxx</a>: 请求的默认全局配置</p><p>axios.interceptors.request.use(): 添加请求拦截器</p><p>axios.interceptors.response.use(): 添加响应拦截器</p><p>axios.create([config]): 创建一个新的 axios(它没有下面的功能)</p><p>axios.Cancel(): 用于创建取消请求的错误对象</p><p>axios.CancelToken(): 用于创建取消请求的 token 对象</p><p>axios.isCancel(): 是否是一个取消请求的错误</p><p>axios.all(promises): 用于批量执行多个异步请求</p><p>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/study/1.webp"  style="zoom:67%;" /><h3 id="axios-create-config">axios.create(config)</h3><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置</p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的</p></li><li><p>为什么要设计这个语法?</p><p>(1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一 样, 如何处理</p><p>(2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p></li></ol><h3 id="拦截器函数-ajax-请求-请求的回调函数的调用顺序">拦截器函数/ajax 请求/请求的回调函数的调用顺序</h3><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程</li><li>流程: 请求拦截器 2 =&gt; 请求拦截器 1 =&gt; 发 ajax 请求 =&gt; 响应拦截器 1 =&gt; 响应拦截器 2 =&gt; 请求的回调</li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><h3 id="取消请求">取消请求</h3><ol><li><p>基本流程</p><p>配置 cancelToken 对象</p><p>缓存用于取消请求的 cancel 函数</p><p>在后面特定时机调用 cancel 函数取消请求</p><p>在错误回调中判断如果 error 是 cancel, 做相应处理</p></li><li><p>实现功能</p><p>点击按钮, 取消某个正在请求中的请求</p><p>在请求一个接口前, 取消前面一个未完成的请求</p></li></ol>]]></content>
    
    
    <summary type="html">Axios学习过程中所记的笔记</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="axios" scheme="https://wjldarling.top/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>ES6-11</title>
    <link href="https://wjldarling.top/posts/e3b2fa21.html"/>
    <id>https://wjldarling.top/posts/e3b2fa21.html</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2023-05-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ECMASript-6-新特性">ECMASript 6 新特性</h2><h3 id="let-关键字">let 关键字</h3><p>let 关键字用来声明变量，使用 let 声明的变量有几个特点：</p><ol><li><p>不允许重复声明</p></li><li><p>块儿级作用域</p></li><li><p>不存在变量提升</p></li><li><p>不影响作用域链</p></li></ol><p><strong>应用场景：以后声明变量使用 let 就对了</strong></p><h3 id="const-关键字">const 关键字</h3><p>const 关键字用来声明常量，const 声明有以下特点</p><ol><li><p>声明必须赋初始值</p></li><li><p>标识符一般为大写</p></li><li><p>不允许重复声明</p></li><li><p>值不允许修改</p></li><li><p>块儿级作用域</p></li></ol><p><strong>注意: 对象属性修改和数组元素变化不会出发 const 错误</strong></p><p>应用场景：声明对象类型使用 const，非对象类型声明选择 let</p><h3 id="变量的解构赋值">变量的解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称 为解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;张学友&quot;</span>, <span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;黎明&quot;</span>, <span class="string">&quot;郭富城&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [zhang, liu, li, guo] = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;林志颖&quot;</span>,</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;车手&quot;</span>, <span class="string">&quot;歌手&quot;</span>, <span class="string">&quot;小旋风&quot;</span>, <span class="string">&quot;演员&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, tags &#125; = lin;</span><br><span class="line"><span class="comment">//复杂解构</span></span><br><span class="line"><span class="keyword">let</span> wangfei = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;王菲&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">songs</span>: [<span class="string">&quot;红豆&quot;</span>, <span class="string">&quot;流年&quot;</span>, <span class="string">&quot;暧昧&quot;</span>, <span class="string">&quot;传奇&quot;</span>],</span><br><span class="line">  <span class="attr">history</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;窦唯&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;李亚鹏&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;谢霆锋&quot;</span> &#125;],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">songs</span>: [one, two, three],</span><br><span class="line">  <span class="attr">history</span>: [first, second, third],</span><br><span class="line">&#125; = wangfei;</span><br></pre></td></tr></table></figure><p><strong>注意：频繁使用对象方法、数组元素，就可以使用解构赋值形式</strong></p><h3 id="模板字符串">模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识，特点：</p><ol><li><p>字符串中可以出现换行</p></li><li><p>可以使用 ${xxx} 形式输出变量</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;沈腾&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;马丽&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;魏翔&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;艾伦&lt;/li&gt;</span></span><br><span class="line"><span class="string">          &lt;/ul&gt;`</span>;</span><br><span class="line"><span class="comment">// 变量拼接</span></span><br><span class="line"><span class="keyword">let</span> star = <span class="string">&quot;王宁&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">`<span class="subst">$&#123;star&#125;</span>在前几年离开了开心麻花`</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：当遇到字符串与变量拼接的情况使用模板字符串</strong></p><h3 id="简化对象写法">简化对象写法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> slogon = <span class="string">&quot;永远追求行业更高标准&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> improve = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;可以提高你的技能&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//属性和方法简写</span></span><br><span class="line"><span class="keyword">let</span> atguigu = &#123;</span><br><span class="line">  name,</span><br><span class="line">  slogon,</span><br><span class="line">  improve,</span><br><span class="line">  <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;可以改变你&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：对象简写形式简化了代码，所以以后用简写就对了</strong></p><h3 id="箭头函数">箭头函数</h3><p>ES6 允许使用「箭头」(=&gt;)定义函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 通用写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">arg1, arg2, arg3</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arg1 + arg2 + arg3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>箭头函数的注意点:</strong></p><ol><li><p>如果形参只有一个，则小括号可以省略</p></li><li><p>函数体如果只有一条语句，则花括号可以省略，函数的返回值为该条语句的 执行结果</p></li><li><p>箭头函数 this 指向声明时所在作用域下 this 的值</p></li><li><p>箭头函数不能作为构造函数实例化</p></li><li><p>不能使用 arguments</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 省略小括号的情况</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn2</span> = (<span class="params">num</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 省略花括号的情况</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn3</span> = (<span class="params">score</span>) =&gt; score * <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. this 指向声明时所在作用域中 this 的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn4</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> school = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;尚硅谷&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">fn5</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">fn5</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：箭头函数不会更改 this 指向，用来指定回调函数会非常合适</strong></p><h3 id="rest-参数">rest 参数</h3><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与 arguments 类似</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//rest 参数必须是最后一个形参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">minus</span>(<span class="params">a, b, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">minus</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：rest 参数非常适合不定个数参数函数的场景</strong></p><h3 id="spread-扩展运算符">spread 扩展运算符</h3><p>扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展开数组</span></span><br><span class="line"><span class="keyword">let</span> tfboys = [<span class="string">&quot;德玛西亚之力&quot;</span>, <span class="string">&quot;德玛西亚之翼&quot;</span>, <span class="string">&quot;德玛西亚皇子&quot;</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(...tfboys);</span><br><span class="line"><span class="comment">//展开对象</span></span><br><span class="line"><span class="keyword">let</span> skillOne = &#123;</span><br><span class="line">  <span class="attr">q</span>: <span class="string">&quot;致命打击&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> skillTwo = &#123;</span><br><span class="line">  <span class="attr">w</span>: <span class="string">&quot;勇气&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> skillThree = &#123;</span><br><span class="line">  <span class="attr">e</span>: <span class="string">&quot;审判&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> skillFour = &#123;</span><br><span class="line">  <span class="attr">r</span>: <span class="string">&quot;德玛西亚正义&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> gailun = &#123; ...skillOne, ...skillTwo, ...skillThree, ...skillFour &#125;;</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1．数组的合并情圣误杀唐探</span></span><br><span class="line"><span class="keyword">const</span> kuaizi =[<span class="string">&#x27;王太利&#x27;</span>,<span class="string">&#x27;肖央&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fenghuang =[<span class="string">&#x27;曾毅&#x27;</span>,<span class="string">&quot;&#x27;玲花&#x27;];</span></span><br><span class="line"><span class="string">//const zuixuanxiaopingguo = kuaizi.concat(fenghuang);</span></span><br><span class="line"><span class="string">const zuixuanxiaopingguo = [ ...kuaizi, ...fenghuang];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//2．数组的克隆</span></span><br><span class="line"><span class="string">const sanzhihua =[ &#x27;E&#x27;, &#x27;G&#x27;, &#x27;M&#x27; ];</span></span><br><span class="line"><span class="string">const sanyecao = [ ...sanzhihua];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//3．将伪数组转为真正的数组</span></span><br></pre></td></tr></table></figure><h3 id="Symbol">Symbol</h3><h4 id="Symbol-基本使用">Symbol 基本使用</h4><p>​ ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的<strong>第七种数据类型</strong>，是一种类似于字符串的数据类型。</p><p>Symbol 特点</p><ol><li><p>Symbol 的值是唯一的，用来解决命名冲突的问题</p></li><li><p>Symbol 值不能与其他数据进行运算</p></li><li><p>Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用 Reflect.ownKeys 来获取对象的所有键名</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Symbol</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1, <span class="keyword">typeof</span> s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加标识的 Symbol（Symbol好比身份证号，参数是姓名）</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2_2 = <span class="title class_">Symbol</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2 === s2_2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Symbol for 定义</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s3_2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3 === s3_2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>注: 遇到唯一性的场景时要想到 Symbol</strong></p><h4 id="对象添加-Symbol-类型属性">对象添加 Symbol 类型属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向对象中添加方法 up down</span></span><br><span class="line"><span class="keyword">let</span> game = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;俄罗斯方块&quot;</span>,</span><br><span class="line">  <span class="attr">up</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="attr">down</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">  <span class="attr">up</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">  <span class="attr">down</span>: <span class="title class_">Symbol</span>(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">game[methods.<span class="property">up</span>] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以改变形状&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">game[methods.<span class="property">down</span>] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以快速下降!!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">let</span> youxi = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;狼人杀&quot;</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;say&quot;</span>)]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以发言&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&quot;zibao&quot;</span>)]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以自爆&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Symbol-内置值">Symbol 内置值</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。可以称这些方法为魔术方法，因为它们会在特定的场 景下自动执行。</p><table><thead><tr><th style="text-align:left">Symbol.hasInstance</th><th style="text-align:left">当其他对象使用 instanceof 运算符，判断是否为该对 象的实例时，会调用这个方法</th></tr></thead><tbody><tr><td style="text-align:left">Symbol.isConcatSpreadable</td><td style="text-align:left">对象的 Symbol.isConcatSpreadable 属性等于的是一个 布尔值，表示该对象用于 Array.prototype.concat()时， 是否可以展开。</td></tr><tr><td style="text-align:left">Symbol.species</td><td style="text-align:left">创建衍生对象时，会使用该属性</td></tr><tr><td style="text-align:left">Symbol.match</td><td style="text-align:left">当执行 str.match(myObject) 时，如果该属性存在，会 调用它，返回该方法的返回值。</td></tr><tr><td style="text-align:left">Symbol.replace</td><td style="text-align:left">当该对象被 str.replace(myObject)方法调用时，会返回 该方法的返回值。</td></tr><tr><td style="text-align:left">Symbol.search</td><td style="text-align:left">当该对象被 str.search (myObject)方法调用时，会返回 该方法的返回值。</td></tr><tr><td style="text-align:left">Symbol.split</td><td style="text-align:left">当该对象被 str.split(myObject)方法调用时，会返回该 方法的返回值。</td></tr><tr><td style="text-align:left">Symbol.iterator</td><td style="text-align:left">对象进行 for…of 循环时，会调用 Symbol.iterator 方法，返回该对象的默认遍历器</td></tr><tr><td style="text-align:left">Symbol.toPrimitive</td><td style="text-align:left">该对象被转为原始类型的值时，会调用这个方法，返 回该对象对应的原始类型值。</td></tr><tr><td style="text-align:left">Symbol. toStringTag</td><td style="text-align:left">在该对象上面调用 toString 方法时，返回该方法的返 回值</td></tr><tr><td style="text-align:left">Symbol. unscopables</td><td style="text-align:left">该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。</td></tr></tbody></table><h3 id="迭代器">迭代器</h3><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提 供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p><ol><li><p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费</p></li><li><p>原生具备 iterator 接口的数据(可用 for of 遍历)</p></li></ol><p>      (1) Array</p><p>      (2) Arguments</p><p>      (3) Set</p><p>      (4) Map</p><p>      (5) String</p><p>      (6) TypedArray</p><p>      (7) NodeList</p><ol start="3"><li>工作原理</li></ol><p>      (1) 创建一个指针对象，指向当前数据结构的起始位置</p><p>      (2) 第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</p><p>      (3) 接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</p><p>      (4) 每调用 next 方法返回一个包含 value 和 done 属性的对象</p><p><strong>注: 需要自定义遍历数据的时候，要想到迭代器。</strong></p><h3 id="生成器">生成器</h3><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;一只没有耳朵&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;一只没有尾巴&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;真奇怪&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">gen</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());</span><br></pre></td></tr></table></figure><p>代码说明：</p><ol><li><p><code>*</code> 的位置没有限制</p></li><li><p>生成器函数返回的结果是迭代器对象，调用迭代器对象的 next 方法可以得到 yield 语句后的值</p></li><li><p>yield 相当于函数的暂停标记，也可以认为是函数的分隔符，每调用一次 next 方法，执行一段代码</p></li><li><p>next 方法可以传递实参，作为 yield 语句的返回值</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟获取  用户数据  订单数据  商品数据</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUsers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&quot;用户数据&quot;</span>;</span><br><span class="line">    <span class="comment">//调用 next 方法, 并且将数据传入</span></span><br><span class="line">    iterator.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOrders</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&quot;订单数据&quot;</span>;</span><br><span class="line">    iterator.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGoods</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">&quot;商品数据&quot;</span>;</span><br><span class="line">    iterator.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> users = <span class="keyword">yield</span> <span class="title function_">getUsers</span>();</span><br><span class="line">  <span class="keyword">let</span> orders = <span class="keyword">yield</span> <span class="title function_">getOrders</span>();</span><br><span class="line">  <span class="keyword">let</span> goods = <span class="keyword">yield</span> <span class="title function_">getGoods</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">gen</span>();</span><br><span class="line">iterator.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><h3 id="Promise">Promise</h3><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数， 用来封装异步操作并可以获取其成功或失败的结果。</p><ol><li><p>Promise 构造函数: Promise (excutor) {}</p></li><li><p>Promise.prototype.then 方法</p></li><li><p>Promise.prototype.catch 方法</p></li></ol><h3 id="Promise-异步方案">Promise 异步方案*</h3><p><a href="https://www.bilibili.com/video/BV1TG411L7KM/?spm_id_from=333.999.0.0&amp;vd_source=e754d95b996bf636e1256b88397221dd">5 分钟彻底学会使用 Promise，你真的懂 Promise 吗？_哔哩哔哩_bilibili</a></p><p>Promise 就是一个对象，用来表示一个异步任务最终结束过后，究竟是成功还是失败。就像是一个承诺，一开始是待定的状态 - Pending ，成功后叫 Fulfilled，失败后叫 Rejected。承诺明确后会有对应的任务执行，onFilfilled, onRejected.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 兑现承诺</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve(100)  // 承诺达成</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;promise rejected&quot;</span>)); <span class="comment">// 承诺失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Promise 对象的 then 方法会返回一个全新的 Promise 对象，所以可以使用链式调用</li><li>后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调</li><li>前面 then 方法中回调函数的返回值会作为后面的 then 方法回调的参数</li><li>如果回调中返回的值是 Promise 那后面的 then 方法回调会等待这个 Promise 结束</li></ul><p>异常处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// then方法的第二个回调函数进行异常捕获</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&quot;/api/users.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onFulfilled&quot;</span>, value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onRejected&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用catch进行异常捕获</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&quot;/api/users.json&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onFulfilled&quot;</span>, value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> <span class="title function_">onRejected</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onRejected&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用 then 的第二个回调捕获异常，只能捕获到前一个抛出的异常，而使用 catch，因为每一个 then 都会返回一个 Promise 对象 所以 catch 首先捕获的是一个 then 的异常，然后会捕获链上往前的异常，也就是 catch 会捕获 catch 以前的异常</p><p><strong>Promise.finally()</strong></p><p>不管成功失败，最后都执行的方法</p><h4 id="Promise-静态方法">Promise 静态方法</h4><p>Promise.resolve（）</p><p>Promise.reject()</p><h4 id="Promise-并行执行">Promise 并行执行</h4><p><strong>Promise.all()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.all 返回一个全新的Promise</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">ajax</span>(<span class="string">&quot;/api/user.json&quot;</span>), <span class="title function_">ajax</span>(<span class="string">&quot;api/posts.json&quot;</span>)]);</span><br><span class="line"><span class="comment">// 所有的Promise完成，全新的promise才会完成</span></span><br><span class="line"><span class="comment">// 所以的异步任务都成功，promise才成功</span></span><br><span class="line"><span class="comment">// 只要有一个异步任务失败，promise就失败</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">values</span>) &#123;</span><br><span class="line">    <span class="comment">// 接收的是数组，包含每个异步任务执行的结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><strong>Promise.race()</strong></p><p>Promise.race()也会将多个 promise 对象组合返回一个新的 promise 对象，但与 all 不同的是：</p><p>all 等待所有任务结束，它才会结束</p><p>race 只会等待第一个结束的任务，也就是只要有一个任务完成了，新的 promise 对象也就完成了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="title function_">ajax</span>(<span class="string">&quot;/api/posts.json&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">  (resolve,</span><br><span class="line">  <span class="function">(<span class="params">reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;timeout&quot;</span>)), <span class="number">500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.race()将多个异步任务组合后返回一个新的promise对象</span></span><br><span class="line"><span class="comment">// 多个异步任务中只要有一个完成（成功或失败），新的promise对象就完成了</span></span><br><span class="line"><span class="comment">// 这里如果request请求在500毫秒内请求成功，就返回成功，使用.then方法</span></span><br><span class="line"><span class="comment">// 如果500毫秒请求没有返回结果，就会reject一个错误，走到catch</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="built_in">require</span>, timeout])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li>Promise.all(): p1, p2, p3 全部返回成功，p 才会返回成功， p1, p2, p3 中任意一个返回失败，p 就返回失败。 失败后，其他异步任务仍会继续执行。</li><li>Promise.race(): p1, p2, p3 任意一个返回成功，p 就返回成功， p1, p2, p3 中任意一个返回失败，p 就返回失败。 失败后，其他异步任务仍会继续执行。</li><li>Promise.allSettled()：等到 p1，p2，p3 全部执行完，不管成功失败，p 的状态为 fulfilled。监听函数接收到的参数时数组[{status:‘fulfilled’, value: 42}, {status:'rejeceted}, reason:-1]</li><li>Promise.any(): p1, p2, p3 只要有一个成功，p 就返回成功，p1，p2，p3 全部失败，p 才返回失败</li></ul><p>Promise 执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;global start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise 2&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise 3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;global end&quot;</span>);</span><br><span class="line"><span class="comment">//计时器最后执行 先执行两个内置命令</span></span><br><span class="line"><span class="comment">// global start</span></span><br><span class="line"><span class="comment">// global end</span></span><br><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="comment">// promise 2</span></span><br><span class="line"><span class="comment">// promise 3</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>按照前面说的，回调进入回调队列，依次执行，可能我们会认为先打印 setTimeout，再打印 promise，但是结果不是这样的。这是因为 js 将任务分为了宏任务和微任务。微任务会插队，在本轮任务的末尾直接执行。</p><p>大部分异步任务都会作为宏任务。</p><p>微任务包括<code>Promise</code>，<code>MutationObserver</code>, <code>process.nextTick/Generator异步方案</code></p><h4 id="手撕-Promise">手撕 Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手撕Promise</span></span><br><span class="line"><span class="comment"> * 首先，promise是一个类,传入一个函数作为参数，直接调用</span></span><br><span class="line"><span class="comment"> * promise 有三个状态， pending， fulfilled， rejected</span></span><br><span class="line"><span class="comment"> * 在 resolve 和 reject调用后状态修改，且状态修改后不能再修改</span></span><br><span class="line"><span class="comment"> * 将 resolve 和 reject 中的参数记录下来，作为 then 方法成功和失败回调的参数</span></span><br><span class="line"><span class="comment"> * 如果 promise 中执行出错，要捕获错误，可以使用try catch来捕获</span></span><br><span class="line"><span class="comment"> * 需要捕获错误的地方包括promise传入的函数执行器，和 then 方法的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECRED</span> = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// promise 传入一个函数，直接调用，函数的参数为 resolve 和 reject</span></span><br><span class="line">      <span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义初始状态</span></span><br><span class="line">  status = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  <span class="comment">// then 方法成功回调的参数</span></span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// then 方法失败回调的参数</span></span><br><span class="line">  error = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 初始化存储 then 回调的值</span></span><br><span class="line">  sCallback = [];</span><br><span class="line">  fCallback = [];</span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态不是 pending ，不做修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// resolve 后将状态修改为成功</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    <span class="comment">// 将结果记录</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="comment">// 如果有储存的成功回调，则调用，数组需要循环调用</span></span><br><span class="line">    <span class="comment">// this.sCallback &amp;&amp; this.sCallback(value)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">sCallback</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">sCallback</span>.<span class="title function_">shift</span>()();</span><br><span class="line">  &#125;;</span><br><span class="line">  reject = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态不是 pending ，不做修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// reject 后将状态修改为失败</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECRED</span>;</span><br><span class="line">    <span class="comment">// 将结果记录</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">error</span> = error;</span><br><span class="line">    <span class="comment">// 如果有储存的失败回调，则调用，数组需要循环调用</span></span><br><span class="line">    <span class="comment">// this.fCallback &amp;&amp; this.fCallback(error)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">fCallback</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">fCallback</span>.<span class="title function_">shift</span>()();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * then 方法参数为成功回调和失败回调</span></span><br><span class="line"><span class="comment">   * 根据状态判断执行哪个回调</span></span><br><span class="line"><span class="comment">   * 如果是异步调用，执行 then 方法时状态还是 pending，则要将两个回调储存起来</span></span><br><span class="line"><span class="comment">   * 储存的方法在 resolve 和 reject 的方法里+</span></span><br><span class="line"><span class="comment">   对应的调用</span></span><br><span class="line"><span class="comment">   * 同一个promise可能会有多个 then 调用，也就会有多组成功和失败的回调，将异步时回调储存为数组</span></span><br><span class="line"><span class="comment">   * then 方法可以链式调用，所以它返回的是一个promise对象，将回调中返回的值作为下一个then方法的参数</span></span><br><span class="line"><span class="comment">   * then 方法返回的promise对象不能是自身,将 newPromise 与 返回值进行判断</span></span><br><span class="line"><span class="comment">   * 在pending状态也要判断不能返回自身</span></span><br><span class="line"><span class="comment">   * then 方法可以不传递参数，不传递参数时，下一个then可以拿到这个then应该拿到的结果</span></span><br><span class="line"><span class="comment">   * 所以 then 不传递参数时，相当于把结果传递到下一个then</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params"></span></span><br><span class="line"><span class="params">    sCallback = (value) =&gt; value,</span></span><br><span class="line"><span class="params">    fCallback = (error) =&gt; &#123;</span></span><br><span class="line"><span class="params">      <span class="keyword">throw</span> error;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newPromise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里是同步执行，所以可以将要执行的操作放在这里</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用后获取返回的值</span></span><br><span class="line">            <span class="keyword">const</span> x = <span class="title function_">sCallback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="comment">// 判断返回的值如果是 promise 对象，根据promise的结果进行resolve和reject</span></span><br><span class="line">            <span class="comment">// 如果是普通值，直接resolve</span></span><br><span class="line">            <span class="comment">// 这个操作在失败是也会调用，所以包装成一个方法</span></span><br><span class="line">            <span class="comment">// then 方法不能返回自己，所以将 newPromise 传进去判断</span></span><br><span class="line">            <span class="comment">// 但是这里其实拿不到newPromise，可以将这段代码放入 setTimeout 中</span></span><br><span class="line">            <span class="comment">// 放入setTimeout 中并不是为了延时，只是为了等 newPromise 创建好了可以引用，所以时间设为0</span></span><br><span class="line">            <span class="title function_">thenValue</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECRED</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="title function_">fCallback</span>(<span class="variable language_">this</span>.<span class="property">error</span>);</span><br><span class="line">            <span class="title function_">thenValue</span>(newPromise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 then 方法时，promise的异步还没执行完，状态还是pending，把两个回调储存</span></span><br><span class="line">        <span class="comment">// 判断不能返回自身</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = <span class="title function_">sCallback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="title function_">thenValue</span>(newPromise, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = <span class="title function_">fCallback</span>(<span class="variable language_">this</span>.<span class="property">error</span>);</span><br><span class="line">              <span class="title function_">thenValue</span>(newPromise, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newPromise;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现finally方法, finally 方法不管promise成功失败都会执行回调</span></span><br><span class="line"><span class="comment">   * finally 会将promise的结果往下传</span></span><br><span class="line"><span class="comment">   * 可以利用 then 方法来实现</span></span><br><span class="line"><span class="comment">   * finally 方法返回一个新的promise对象,由于then方法就是返回一个promise对象，所以直接返回</span></span><br><span class="line"><span class="comment">   * 如果finally返回一个promise对象，要等promise对象有了结果，才会执行下方的 then</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">      <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现 catch,catch方法只有一个回调，就是失败回调,返回一个promise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">catch</span>(callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现一个all方法, all 方法传入一个数组，数组中会有异步调用，返回一个新的promise对象</span></span><br><span class="line"><span class="comment">   * 数组中所有异步都成功，将结果以数组形式返回，否则一个出错就出错</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">addData</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        results[key] = value;</span><br><span class="line">        <span class="comment">// index代表给results中添加了几个值，如果index和args长度相等，说明全部成功</span></span><br><span class="line">        <span class="comment">// 不能用results长度来判断，因为results赋值不是通过 push 方法，而是针对 key 来赋值的</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index == args.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(results);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 判断是promise对象还是普通值，普通值直接加入results数组</span></span><br><span class="line">        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// promise 对象</span></span><br><span class="line">          args[i].<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">addData</span>(i, value);</span><br><span class="line">          &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 普通值</span></span><br><span class="line">          <span class="title function_">addData</span>(i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现一个Promise.resolve方法</span></span><br><span class="line"><span class="comment">   * Promise.resolve方法后面要接 then 方法</span></span><br><span class="line"><span class="comment">   * 参数如果是个promise对象，就按照这个promise执行，返回它</span></span><br><span class="line"><span class="comment">   * 参数如果是个普通值，创建一个新的promise对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Promise.reject 方法，返回一个新的Promise，状态为reject</span></span><br><span class="line"><span class="comment">   * 参数原封不动的作为reject的理由</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thenValue</span>(<span class="params">newPromise, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (newPromise === x) <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;then方法不能返回自己&quot;</span>));</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是promise对象</span></span><br><span class="line">    x.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是普通值</span></span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set">Set</h3><p>ES6 提供了新的数据结构 Set（集合）。它类似于数组，但成员的值都是唯 一的，集合实现了 <code>iterator</code> 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历，集合的属性和方法：</p><ol><li><p>size 返回集合的元素个数</p></li><li><p>add 增加一个新元素，返回当前集合</p></li><li><p>delete 删除元素，返回 boolean 值</p></li><li><p>has 检测集合中是否包含某个元素，返回 boolean 值</p></li><li><p>clear 清空集合，返回 undefined</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空集合</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="comment">//创建一个非空集合</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//集合属性与方法</span></span><br><span class="line"><span class="comment">//返回集合的元素个数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">size</span>);</span><br><span class="line"><span class="comment">//添加新元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">add</span>(<span class="number">4</span>));</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">delete</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//检测是否存在某个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">has</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//清空集合</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="title function_">clear</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">//1. 数组去重</span></span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">//2. 交集</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// let result = [...new Set(arr)].filter(item =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     let s2 = new Set(arr2);// 4 5 6</span></span><br><span class="line"><span class="comment">//     if(s2.has(item))&#123;</span></span><br><span class="line"><span class="comment">//         return true;</span></span><br><span class="line"><span class="comment">//     &#125;else&#123;</span></span><br><span class="line"><span class="comment">//         return false;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简写</span></span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Set</span>(arr2).<span class="title function_">has</span>(item));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//[4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 并集</span></span><br><span class="line"><span class="keyword">let</span> union = [...<span class="keyword">new</span> <span class="title class_">Set</span>([...arr, ...arr2])];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(union); <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 差集</span></span><br><span class="line"><span class="keyword">let</span> diff = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)].<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> !<span class="keyword">new</span> <span class="title class_">Set</span>(arr2).<span class="title function_">has</span>(item));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(diff); <span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="Map">Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键” 的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。Map 的属 性和方法：</p><ol><li><p>size 返回 Map 的元素个数</p></li><li><p>set 增加一个新元素，返回当前 Map</p></li><li><p>get 返回键名对象的键值</p></li><li><p>has 检测 Map 中是否包含某个元素，返回 boolean 值</p></li><li><p>clear 清空集合，返回 undefined</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空 map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//创建一个非空 map</span></span><br><span class="line"><span class="keyword">let</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;尚硅谷&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;slogon&quot;</span>, <span class="string">&quot;不断提高行业标准&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性和方法</span></span><br><span class="line"><span class="comment">//获取映射元素的个数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m2.<span class="property">size</span>); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//添加映射值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m2.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">//获取映射值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m2.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="comment">//检测是否有该映射</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m2.<span class="title function_">has</span>(<span class="string">&quot;age&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//清除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m2.<span class="title function_">clear</span>());</span><br></pre></td></tr></table></figure><h3 id="class-类">class 类</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对 象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是 一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象 原型的写法更加清晰、更像面向对象编程的语法而已。 知识点：</p><ol><li><p>class 声明类</p></li><li><p>constructor 定义构造函数初始化</p></li><li><p>extends 继承父类</p></li><li><p>super 调用父级构造方法</p></li><li><p>static 定义静态方法和属性</p></li><li><p>父类方法可以重写</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">brand, color, price</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//对象方法</span></span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以打电话!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">brand, color, price, screen, pixel</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(brand, color, price);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">screen</span> = screen;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pixel</span> = pixel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子类方法</span></span><br><span class="line">  <span class="title function_">photo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以拍照!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">playGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以玩游戏!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法重写</span></span><br><span class="line">  <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以进行视频通话!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以运行程序&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以建立连接&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Nokia</span> = <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;诺基亚&quot;</span>, <span class="string">&quot;灰色&quot;</span>, <span class="number">230</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone6s = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;白色&quot;</span>, <span class="number">6088</span>, <span class="string">&quot;4.7inch&quot;</span>, <span class="string">&quot;500w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用子类方法</span></span><br><span class="line">iPhone6s.<span class="title function_">playGame</span>();</span><br><span class="line"><span class="comment">//调用重写方法</span></span><br><span class="line">iPhone6s.<span class="title function_">call</span>();</span><br><span class="line"><span class="comment">//调用静态方法</span></span><br><span class="line"><span class="title class_">SmartPhone</span>.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><h3 id="数值扩展">数值扩展</h3><p>Number.EPSILON 是 JavaScript 表示的最小精度<br>EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16</p><p><strong>二进制和八进制</strong></p><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。</p><p><strong>Number.isFinite() 与 Number.isNaN()</strong></p><p>Number.isFinite() 用来检查一个数值是否为有限的</p><p>Number.isNaN() 用来检查一个值是否为 NaN</p><p><strong>Number.parseInt() 与 Number.parseFloat()</strong></p><p>ES6 将全局方法 parseInt 和 parseFloat，移植到 Number 对象上面，使用不变。</p><p><strong>Number.isInteger</strong></p><p>Number.isInteger() 用来判断一个数值是否为整数</p><p><strong>Math.trunc</strong></p><p>用于去除一个数的小数部分，返回整数部分。</p><p><strong>Math.sign</strong></p><p>判断一个数是正、负还是 0</p><h3 id="对象扩展">对象扩展</h3><p>ES6 新增了一些 Object 对象的方法</p><ol><li><p><a href="http://Object.is">Object.is</a> 比较两个值是否严格相等，与『===』行为基本一致（+0 与 NaN）</p></li><li><p>Object.assign 对象的<strong>合并</strong>，将源对象的所有可枚举属性，复制到目标对象</p></li><li><p><code>__proto__</code>、<code>setPrototypeOf</code>、 <code>setPrototypeOf</code> 可以直接设置对象的原型</p></li></ol><h3 id="模块化">模块化</h3><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><h4 id="模块化的好处">模块化的好处</h4><p>模块化的优势有以下几点：</p><ol><li><p>防止命名冲突</p></li><li><p>代码复用</p></li><li><p>高维护性</p></li></ol><h4 id="模块化规范产品">模块化规范产品</h4><p>ES6 之前的模块化规范有：</p><ol><li><p>CommonJS =&gt; NodeJS、Browserify</p></li><li><p>AMD =&gt; requireJS</p></li><li><p>CMD =&gt; seaJS</p></li></ol><h4 id="ES6-模块化语法">ES6 模块化语法</h4><p>模块功能主要由两个命令构成：export 和 import。</p><ul><li>export 命令用于规定模块的对外接口</li><li>import 命令用于输入其他模块提供的功能</li></ul><h5 id="export-三种暴露方式">export 三种暴露方式</h5><p>分别暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我们可以教给你开发技能&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> school = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我们可以帮助你找工作!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; school, findJob &#125;;</span><br></pre></td></tr></table></figure><p>默认暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&quot;ATGUIGU&quot;</span>,</span><br><span class="line">  <span class="attr">change</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我们可以改变你!!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="import-引入方式">import 引入方式</h5><p>通用的导入方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入 m1.js 模块内容</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&quot;./src/js/m1.js&quot;</span>;</span><br><span class="line"><span class="comment">//引入 m2.js 模块内容</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">&quot;./src/js/m2.js&quot;</span>;</span><br><span class="line"><span class="comment">//引入 m3.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>;</span><br></pre></td></tr></table></figure><p>解构赋值形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; school, teach &#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; school <span class="keyword">as</span> guigu, findJob &#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m2.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> m3 &#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>; <span class="comment">//default必须要用别名</span></span><br></pre></td></tr></table></figure><p>简便形式 针对默认暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="ECMASript-7-新特性">ECMASript 7 新特性</h2><h4 id="Array-prototype-includes">Array.prototype.includes</h4><p>Includes 方法用来检测数组中是否包含某个元素，返回布尔类型值</p><h4 id="指数操作符">指数操作符</h4><p>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</p><h2 id="ECMASript-8-新特性">ECMASript 8 新特性</h2><h3 id="async-和-await">async 和 await</h3><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><p><a href="https://knightyun.github.io/2019/08/02/js-async-await">async、await 详解</a></p><h4 id="async-函数">async 函数</h4><p>1、async 函数的返回值为 promise 对象</p><p>2、promise 对象的结果由 async 函数执行的返回值决定</p><h4 id="await-表达式">await 表达式</h4><p>1、await 必须写在 async 函数中</p><p>2、await 右侧的表达式一般为 promise 对象</p><p>3、await 返回的是 promise 成功的值</p><p>4、await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</p><h5 id="Async-Await-语法糖">Async/Await 语法糖</h5><p>基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比普通的函数多了一个 *</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用 yield 返回一个值，next 方法返回的就是这个值</span></span><br><span class="line">  <span class="comment">// yield 不会结束生成器的执行，只是 暂停</span></span><br><span class="line">  <span class="comment">// 如果next方法传入一个参数，会作为上一个yield 的返回值</span></span><br><span class="line">  <span class="comment">// yield &#x27;foo&#x27;</span></span><br><span class="line">  <span class="comment">// const res = yield &#x27;foo&#x27;</span></span><br><span class="line">  <span class="comment">// console.log(res) // bar</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// bar</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用生成器并不会立即执行，而是得到一个生成器对象</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用next方法，函数体才会执行</span></span><br><span class="line"><span class="keyword">const</span> result = generator.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// 返回结果中有一个done属性，表示生成器是否一起执行完了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//&#123;value: &quot;foo&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再一次调用next方法时，会从 yield 位置开始执行</span></span><br><span class="line">generator.<span class="title function_">next</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用生成器的throw方法，也会继续往下执行，但是它会抛出一个异常</span></span><br><span class="line"><span class="comment">// 在生成器内部使用try&#123;&#125;catch()&#123;&#125;语句来接收异常</span></span><br><span class="line">generator.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Generator error&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">yield</span> <span class="title function_">ajax</span>(url1);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(users);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> posts = <span class="keyword">yield</span> <span class="title function_">ajax</span>(url2);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(posts);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">generator</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleResult</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(</span><br><span class="line">      <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>(data));</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        g.<span class="keyword">throw</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(main);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将生成器的 * 改为 async ，yield 改为 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> <span class="title function_">ajax</span>(url1);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(users);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">ajax</span>(url2);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(posts);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接调用，不需要 co</span></span><br><span class="line"><span class="comment">// async 函数返回一个promise对象</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">main</span>();</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;all completed&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Object-values-和-Object-entries">Object.values 和 Object.entries</h3><p>1、Object.values()方法返回一个给定对象的所有可枚举属性值的数组</p><p>2、Object.entries()方法返回一个给定对象自身可遍历属性 [key,value] 的数组</p><h3 id="Object-getOwnPropertyDescriptors">Object.getOwnPropertyDescriptors()</h3><p>该方法返回指定对象所有自身属性的描述对象</p><h2 id="ECMASript-9-新特性">ECMASript 9 新特性</h2><h4 id="Rest-Spread-属性">Rest/Spread 属性</h4><p>Rest 参数与 spread 扩展运算符在 ES6 中已经引入，不过 ES6 中只针对于数组， 在 ES9 中为对象提供了像数组一样的 rest 参数和扩展运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">&#123; host, port, ...user &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(host);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(port);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">connect</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="正则表达式命名捕获组">正则表达式命名捕获组</h4><p>ES9 允许命名捕获组使用符号<code>『?&lt;name&gt;』</code>,这样获取捕获结果可读性更强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&lt;a href=&quot;http://www.atguigu.com&quot;&gt;尚硅谷&lt;/a&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;a href=&quot;(?&lt;url&gt;.*)&quot;&gt;(?&lt;text&gt;.*)&lt;\/a&gt;/</span>;</span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">groups</span>.<span class="property">url</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">groups</span>.<span class="property">text</span>);</span><br></pre></td></tr></table></figure><h4 id="正则表达式反向断言">正则表达式反向断言</h4><p>ES9 支持反向断言，通过对匹配结果前面的内容进行判断，对匹配进行筛选。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;JS5211314 你知道么 555 啦啦啦&quot;</span>;</span><br><span class="line"><span class="comment">//正向断言</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d+(?=啦)/</span>; <span class="comment">//判断后面是不是 啦</span></span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line"><span class="comment">//反向断言</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/(?&lt;=么)\d+/</span>; <span class="comment">//判断前面是不是 么</span></span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure><h4 id="正则表达式">正则表达式</h4><p>dotAll 模式 正则表达式中点 . 匹配除回车(换行符)外的任何单字符，标记『s』改变这种行为，允许行 终止符出现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;</span></span><br><span class="line"><span class="string"> &lt;a&gt;肖申克的救赎&lt;/a&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;上映日期: 1994-09-10&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/li&gt;</span></span><br><span class="line"><span class="string"> &lt;li&gt;</span></span><br><span class="line"><span class="string"> &lt;a&gt;阿甘正传&lt;/a&gt;</span></span><br><span class="line"><span class="string"> &lt;p&gt;上映日期: 1994-07-06&lt;/p&gt;</span></span><br><span class="line"><span class="string"> &lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"><span class="comment">//声明正则</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;li&gt;.*?&lt;a&gt;(.*?)&lt;\/a&gt;.*?&lt;p&gt;(.*?)&lt;\/p&gt;/g</span>s;</span><br><span class="line"><span class="comment">//执行匹配</span></span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(str);</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">while</span> ((result = reg.<span class="title function_">exec</span>(str))) &#123;</span><br><span class="line">  data.<span class="title function_">push</span>(&#123; <span class="attr">title</span>: result[<span class="number">1</span>], <span class="attr">time</span>: result[<span class="number">2</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure><h2 id="ECMASript-10-新特性">ECMASript 10 新特性</h2><p><strong>Object.fromEntries</strong></p><p><strong>trimStart 和 trimEnd</strong></p><p>清除字符串左边与右边空白</p><p><strong>Array.prototype.flat 与 flatMap</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flat将多维数组转化为低维数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flat</span>()); <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, (<span class="number">6</span>)[(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]]];</span><br><span class="line"><span class="comment">//参数为深度是一个数宁</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">flat</span>(<span class="number">2</span>)); <span class="comment">//[1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flatMap</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">flatMap</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> [item * <span class="number">10</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//[10,20,30,40]</span></span><br></pre></td></tr></table></figure><p><strong>Symbol.prototype.description</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbo1</span>(<span class="string">&quot;尚硅谷&#x27;);</span></span><br><span class="line"><span class="string">console.log(s.description);//尚硅谷</span></span><br></pre></td></tr></table></figure><h2 id="ECMASript-11-新特性">ECMASript 11 新特性</h2><p><strong>String.prototype.matchAll</strong>方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器</p><p><strong>类的私有属性</strong></p><p>在私有属性前面加#代表类的私有属性</p><p><strong>Promise.allSettle</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明两个promise对象</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;商品数据-1&#x27;</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//resolve(&#x27;商品数据– 2&#x27;);</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;出错啦!&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//调用allsettled方法</span></span><br><span class="line"><span class="keyword">const</span> resul = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1，p2]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//返回结果始终是成功的，返回的值是promise对象的值</span></span><br></pre></td></tr></table></figure><p><strong>可选链操作符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">//const dbHost = config &amp;&amp; config.db 8&amp; config.db.host;</span></span><br><span class="line">  <span class="keyword">const</span> dbHost = config?.<span class="property">db</span>?.<span class="property">host</span>; <span class="comment">//?. 判断前面的config是否传入，没传入则为undefined，传入之后判断是否有db再获取host</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dbHost); <span class="comment">//192.168.1.100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>(&#123;</span><br><span class="line">  <span class="attr">db</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;192.168.1.100&quot;</span>,</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;192.168.1.208&quot;</span>,</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>动态 import 导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给btn按钮绑定事件</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./hello.js&#x27;</span>).<span class="title function_">then</span>( <span class="function"><span class="params">module</span> =&gt;</span> &#123;&#125;\</span><br><span class="line"><span class="variable language_">module</span>.<span class="title function_">hello</span>();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BigInt</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大整形</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">521n</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n, <span class="keyword">typeof</span> n); <span class="comment">//521n &quot;bigint&quot;</span></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(n)); <span class="comment">//123n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(<span class="number">1.2</span>)); <span class="comment">//不能进行浮点型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大数值运算</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max); <span class="comment">//9007199254740991</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max + <span class="number">1</span>); <span class="comment">//9007199254740992</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max + <span class="number">2</span>); <span class="comment">//9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(max)); <span class="comment">//9007199254740991n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(max) + <span class="title class_">BigInt</span>(<span class="number">1</span>)); <span class="comment">//9087199254740992n</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">BigInt</span>(max) + <span class="title class_">BigInt</span>(<span class="number">2</span>)); <span class="comment">//9007199254740993n</span></span><br></pre></td></tr></table></figure><p><strong>globalThis 对象</strong> 始终指向全局对象</p>]]></content>
    
    
    <summary type="html">ES6-11新特性-学习过程中记的笔记</summary>
    
    
    
    <category term="前端" scheme="https://wjldarling.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="js" scheme="https://wjldarling.top/tags/js/"/>
    
    <category term="es6" scheme="https://wjldarling.top/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>个人博客</title>
    <link href="https://wjldarling.top/posts/b5ea4f7a.html"/>
    <id>https://wjldarling.top/posts/b5ea4f7a.html</id>
    <published>2023-05-21T12:49:08.000Z</published>
    <updated>2023-05-21T12:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>  先分享一下我的个人博客地址<br>  标题：你好可爱<br>  链接：<a href="https://wjldarling.top/">https://wjldarling.top/</a><br>  欢迎来访！</p><p>  从上周开始，我开始搭建我的个人博客了，因为看他们都有个人博客，感觉比较厉害，而且这也是自己的小空间，感觉很有意义吧，自己想弄成什么样弄成什么样的。</p><p>  刚开始不会，然后就照着大佬的文章一步一步走，<a href="https://blog.cuijiacai.com/blog-building/">博客搭建</a>（参考这位大佬的搭建教程），基于 hexo+butterfly 搭建的博客，托管是基于 netlify+cloudflare，去阿里云买的域名，刚开始都不懂，然后陆陆续续搞了一周最后给博客搭建起来了，中间更改了好多次，主题也是根据<a href="https://github.com/fomalhaut1998/hexo-theme-Fomalhaut">猕猴桃 🥝</a> 大佬的魔改主题自己更改了很多，改成自己想要的样子，中间出了好多 bug，第一次啥也不明白，然后搞了半天最后重新搭了，后来搞明白了，然后 git 指令啥的从上一次项目开始接触，到现在一直在用，经常上传代码啥的，慢慢变熟练。</p><p>  对于图床的配置用的 picgo+github，昨天的时候搞的阿里云 oss，但是感觉有些没必要，就决定换回来，白掏钱了。</p><p>  现在博客搭起来了，欢迎各位访问，以后也会更频繁的写博客了，一起学习！</p>]]></content>
    
    
    <summary type="html">个人博客</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
    <category term="博客" scheme="https://wjldarling.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>青岛三日游</title>
    <link href="https://wjldarling.top/posts/87881f47.html"/>
    <id>https://wjldarling.top/posts/87881f47.html</id>
    <published>2023-05-21T12:33:04.000Z</published>
    <updated>2023-05-21T12:33:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>  又是闲来无事，写篇简书，好久没有记录了，好好缕缕最近发生的事情吧。</p><p>  就写写四月多计划出去旅游，原本的准备五一去旅游，然后订计划，准备订房的时候，一看五一房价一间五六百，乖乖嘞，平时一百多的房，五一那么贵，就商量着提前去，然后最后研究研究决定四月二十号去，然后坐一晚上车，早上到站，进行了三天的旅游，三天的旅游计划如下，我研究了好久做的攻略</p><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/weekly_report/28.webp" style="height:1.5em"/><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/weekly_report/29.webp" style="height:1.5em"/><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/weekly_report/30.webp" style="height:1.5em"/><img no-lazy class="inline" src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/weekly_report/27.webp" style="height:1.5em"/><p>  一共规划了三天了游玩路线自己吃饭的地方，但是因为有些不可抗力导致有的地方没去逛，但是问题不大，总的来说是挺开心的，第一次出去旅游，第一次做旅游攻略（真滴难做），先选景点，然后看时间门票，再规划一下时间，分配合理路线，然后就订票啥的，最后再算算钱啥的，我们总共四个人，人均一千左右，感觉还算可以，下面这个是价格表，本来也规划了去景点坐地铁啥的，但是最后都是打车去的</p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/weekly_report/31.webp" style="zoom:50%;" /><p>  最后一天遇到了个出租车司机阿姨，给我们讲了当地的情况啥的，以及去哪吃饭划算等等，只可惜那天我们就要回去了。</p><p>  吃饭地方的话本人极力推荐六七八炭火烤屋，四个人点了个套餐直接吃撑，而且还很好吃，挺划算，第一个船小鲜的话我个人感觉不是那么实惠好吃，然后阿姨推荐的饭店啥的在银鱼巷附近，有兴趣出去玩的伙伴可以去尝尝。</p><p>  总的来说第一次出去玩挺满意的，唯一不太行的就是我的拍照技术太烂了，拍不出来好看的照片，唉。</p>]]></content>
    
    
    <summary type="html">青岛三日游</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
    <category term="旅游" scheme="https://wjldarling.top/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>2023.03.13</title>
    <link href="https://wjldarling.top/posts/ca9997af.html"/>
    <id>https://wjldarling.top/posts/ca9997af.html</id>
    <published>2023-03-13T03:17:56.000Z</published>
    <updated>2023-03-13T03:17:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>  又是两周没写简书了，md 老偷懒，小叙一下这两周吧。</p><p>  首先学习方面，把 vue2 后台项目给弄完了，到后面有个 bug 也懒得管了，也没搞多少东西，感觉有点混，也是老打游戏，下棋，有时候懒得去 12 号楼就在宿舍学，但是在宿舍就容易打游戏，算法的话在学习二叉树，打算这周把安排的算法题搞完，然后开始往后每天一道算法题保持住，下周的话把 vue3 过完，然后再往后搞 ts。每天还准备读书半个小时。</p><p>  然后是生活方面吧，去拔了个智齿，拔的时候怪疼，剩一点在里面然后就一直捯饬，现在已经好差不多了，等他自己长好了。再者就是昨天考的四级，怎么说呢，裸考，刚开始写作文，勉强看懂个题目，本来应该是一个学者发表文献啥的吧好像，我以为是校长演讲啥的，反正就在那扯学习，扯了 50 个词扯不动了，本来准备摆烂了，然后该听听力的时候我一翻前面阅读，感觉差不多，然后抄了一段，起码字数够了。然后听力也听不懂，阅读啥的也看不懂，抄了别人的听力还有最后两篇阅读，不知道卷一样不一样，开摆就完了。然后 md 昨天上午手机坏了，开不开机了，去手机店说是 cpu 坏了，修了修 120 大洋，然后昨天晚上赶紧给我手机上的照片啥的备份了一下子，传到 u 盘上了，快该换新手机了要</p>]]></content>
    
    
    <summary type="html">2023.03.13</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>不上课的一周</title>
    <link href="https://wjldarling.top/posts/6deeb4f4.html"/>
    <id>https://wjldarling.top/posts/6deeb4f4.html</id>
    <published>2023-02-27T02:39:29.000Z</published>
    <updated>2023-02-27T02:39:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>  上周又是一堆课，14 节，依旧一节课没去，天天早上睡到自然醒，下午以及晚上去学习，感觉效率还挺高，睡的也舒服。</p><p>  学习方面，上周还是在搞后台项目，搞了两个大模块的开发，用 elementui 搭建的，算法方面就没进行，感觉就是忙着专心搞这个后台项目嘞。</p><p>  昨天的话，接触了一个 tiktok 以及跨境电商，碰到了个直播讲课的，大概讲的就是国外的 tiktok 刚发展不久，用户基数大，发作品或者操作作品的话流量比较大，号容易养起来，养起来之后再进行带货，挂那个讲课他们已有的链接，然后给我 30%-70%的佣金，等差不多了再进行自己开店或者挂购物袋这样一种模式，赚一个汇率差，我感觉挺心动的啥的，感觉是个机会吧，我又去多查了查，跨境电商的话再之前几年搞的人比较多，国外网上开店的有四分之三差不多都是中国人，现在相对少了些，但是对于刚兴起的 tiktok 我感觉其实有点机会的，但是课的话待交钱，自己摸索的话又挺慢的，就很难搞感觉，打算自己搞个 tiktok 先慢慢弄着，那个卖课的又不太能信。</p>]]></content>
    
    
    <summary type="html">不上课的一周</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>又是开学第一周</title>
    <link href="https://wjldarling.top/posts/7f3c58c5.html"/>
    <id>https://wjldarling.top/posts/7f3c58c5.html</id>
    <published>2023-02-16T14:53:00.000Z</published>
    <updated>2023-02-16T14:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  大三下学期开学了，时间过的真快啊，再有一年就要毕业了，感慨万千啊。</p><p>  开学前，在这有个烟花展，晚上五点从园区出发，走了四五公里，一个多小时，到了地方，人挤人，都挤不动都，好不容易挤了一个位置，看不到多少烟花，又往边上挤一挤，更看不到了，我们几个人就找了个饭店吃饭了，手机也没有网，走了一俩小时就看了两眼烟花，还不如给网上看看嘞，吃完饭又走回去，走到一半扫了个车回去了，回去已经十点了，这来来回回 5 个小时，吃个饭，泡个澡，剩下时间不是想干啥干啥，非要当大怨种去看烟花，血亏。</p><p>  再说开学，上学期考试必然全过，线上考试八仙过海，各凭本事。然而这学期的课真多，平均一天三节课，周三周四周五都是早八，无所谓，我不会去上，这两天早上我直接睡到十点，是真滴香啊，课也不怎么去，有空就去去年的教室学习，这次坐在了门口，里面都是计科专业考研的，刚好给我们留了 10 个位置让我们学习，也挺好的。这学期考试课就四门，还都是大合教，只能说，挂不了，根本挂不了。这学期不出意外我不怎么去上课，赶赶进度，多学习学习，今年秋招抓住机会先试试水。</p><p>  周一的时候我研究了一节课海底捞，毕竟没去吃过，研究了他们海底捞员工推荐的怎么吃能吃饱也划算，以及大学生 69 折，然后终于研究明白了，跑去美团上预约海底捞座位，然后发现到 20 号下午的 2 点到 6 点都是爆满，我 nm，后来改方案决定去吃椰子鸡，我对象也心心念念了好久的椰子鸡，吃着感觉还不赖，价钱也不赖（doge），小贵，呜呜呜，要找个好工作实现吃饭自由。</p><p>  学习上的呢，这周把 vue3 给看完了，天禹老师真的强，我感觉是讲的最好的老师没有之一，最后一集都在完结散花，好感动，但是弹幕上来了个感谢 pink 老师，哈哈哈哈，是不是有毛病（doge），一下就给我整笑了，然后今天下午去写了五个实验报告，晚上的时候做了 5 道算法题，感觉还不赖，打算这周尽量给那四十道算法题弄完，加油！！！学就完了</p>]]></content>
    
    
    <summary type="html">又是开学第一周</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2022-2023跨年</title>
    <link href="https://wjldarling.top/posts/5042100a.html"/>
    <id>https://wjldarling.top/posts/5042100a.html</id>
    <published>2023-01-22T14:31:29.000Z</published>
    <updated>2023-01-22T14:31:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>  好久没写了，一个假期了，这个假期发生了好多好多事情。</p><p>  去年 12 月初，因为奶奶去世加上 yi 情严重，我早早的就往回家赶，回到家被隔离在姨奶家，隔离了一个多星期，坐在屋里也依然是天天学习，就是有点冷，天天手都冻僵了，然后隔离完之后给我奶奶办办丧事，以后就回到我家里，也是继续学习。本来打算假期在园区学习嘞，也没去成，在园区的同学们也都阳了不少，也没学多少。后来国家的政策也放开了，保护了我们三年，发育了三年，终于要出去了，我爷解封以后去赶集也阳了，然后就开始照顾我爷爷，我爷阳康之后，我达回新郑之后他们家也阳了，然后我跟我妹妹也相继发烧了，我躺了三天，天天喝姜茶，好在味不是很浓，年后我爸给我弄了碗很浓的姜茶，给我喝的想 yue，然后假期慢慢安顿下来，也过了个年，在大年初六的时候，我又回到了新乡，来到园区学习，见到了好朋友们。</p><p>  来到园区以后呢，学了两天开始开会谈合同的事情了，他们第一批的是在大二的暑假之前进的，他们在暑假之后就签合同算家族成员了，我们第二批的是在大二寒假之前进的，一直没签合同，然后开会讲了一堆新合同，还有另外的方案，又或者是退出，说了好多也起了分歧，我也思考了非常久，后来找了学长学姐一起吃了顿饭，畅谈了许多，退的话需要组织起来，但是我们组织不起来，留下来说个好听了就是起码有个保障了，有个低保心里踏实点，怕自己弄的话找不到工作，然后我们二批的五个选了另一个方案，也开始了正式的学习，他们大部分人也都留下来安定下来了，开始了在学校的学习与生活。。。</p><p>  虽然不在家族里了，也不用每周必须写简书了，但是也算是养成习惯了，以后也会每周继续写的，大家一起加油！！！</p>]]></content>
    
    
    <summary type="html">2022-2023跨年</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>紫罗兰永恒花园</title>
    <link href="https://wjldarling.top/posts/ab31d243.html"/>
    <id>https://wjldarling.top/posts/ab31d243.html</id>
    <published>2022-12-12T00:40:49.000Z</published>
    <updated>2022-12-12T00:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>  从前，车马很慢，书信很远，一生只够爱一人。</p><p><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/inspiration/19.webp" alt=""></p><p>  “信”对你来说意味着什么呢？是从前的人们传达讯息的工具？现代化社会的我们拥有了覆盖着整个世界的网络和智能手机，相隔甚远的对方能通过上述方式第一时间收到你想传达的信息。有了这些，我们是否也能做到更多的事情呢？互联网是这个时代的象征之一，平和无战乱，不断进步的科技成果，我们对于世界的了解变得更容易，有更多的内容摆在了面前，我们心里想要的东西，似乎也有所改变了。</p><p>  薇尔莉特所处的年代，在深夜想见的那个人，远方的家人，分别的挚友，心上人，脑海里无数想说出的话，见面的时间似乎有限，仿佛一下子也说不完呢。于是书信成了传达的最佳方式，将心中的千言万语化为温柔的文字，字里行间那细腻的感情仿佛就要溢出来，“欲作家书意万重，复恐匆匆说不尽，行人临发又开封”。于是便有了期待和小小的躁动，期待着对方能感受到这份心意和他/她的回音。在书信往来的同时，对方也与你有着相同的心情。此外有些说不出口的话，也能通过书信传达。就像爱丽丝的那封给父母的信一样。正因为通讯不方便，也不容易，才会更期待、更珍惜与心里那个人的相遇的每一天。未来的事情无人能够预料，但只要心中有了期许和念想，又何尝不是一种意义呢？现代的我们，是否就变得很难体会到这种特殊的感情和意义呢？</p><p>  薇尔莉特所处的年代，有战乱纷扰，女主角本人就是战争悲剧的受害者，从小不知道父母是谁，被作为战斗机器般培养，失去一个普通小女孩的天真烂漫。所幸她遇到了少佐，这个善良温厚的男人将她视作普通的孩子看待，耐心地教会她读书识字，是少佐给予了薇尔莉特活下去的理由。薇尔莉特后来选择从事代写书信的工作，也是为了回应少佐的期待，做到不辜负他。自己也慢慢成长，慢慢理解“爱”的含义，重获丰富的感情。令我动容的是，剧情达到高潮部分，薇尔莉特知道真相后悲痛欲绝，她掐住了自己的脖子，但最终没有做出那个选择而是继续走下去。我相信，一定是冥冥之中她似乎明白，不能这样做，要是那个人看到了，会不忍心的。就不能回应他的期待了。他希望我活下去一定有他的理由。她回到公司，伙伴们的身边，不停下前进的脚步，也是希望有一天能以另一种不一样的神态向少佐作出理想的汇报。</p><p>  薇尔莉特所处的年代，战火蔓延，病魔无情，薇尔莉特受伤失去亲爱的人，其他人们的生命也时常脆弱无助。奥斯卡失去了他的女儿，安妮失去了她的母亲……人们是否就会思考：命运无常，生命短暂，这个世界，究竟什么东西才是永恒的？战争和疾病夺去了我身边的人，我失去了，更深刻地体会到了他/她于我的重要。虽然不在了，但我永远不会忘记他/她，也无法忘记。他/她于我的影响，也永远不会消失的。这也就像女主角本人，她的名字，这种美丽的花，一部为了爱妻而诞生的伟大发明，这部唯美的动漫作品的名字一样，是永恒而质朴的爱。没有杂质，没有虚伪。</p><div style="display:flex;justify-content:space-around"><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/inspiration/20.webp" /><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/inspiration/21.webp" /></div><div style="display:flex;justify-content:space-around"><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/inspiration/22.webp" /><img src="https://cdn.staticaly.com/gh/1405720461/blog_img@main/inspiration/23.webp" /></div><p>  因为爱，我们才存在。父母使我们降生于世，成为我们第一任启蒙老师，带领我们认识这个世界。我们带着对父母的感激和爱，在成长的道路上不断前进。如果学会去爱身边最亲的人，也就能体会到爱的意义，从而化“小爱”为“大爱”，进而去爱这个世界，用爱感染身边每一个人，让更多的人能感受到真诚和善意。这就是薇尔莉特能写下无数封美好的书信使善良的人们结缘，人们也因此记住了这位可爱的少女，实现自身价值的原因所在吧。</p><p>  特别喜欢《航海王》一首片尾曲中的歌词“虽然那充满泪水的日子已经远去，但仍想请你不要忘记，那些与你分担烦恼和痛苦的伙伴们都还在这里。”虽然疾苦的年代过去了，或者说曾经一段困难的时光过去了，在如今这个快节奏的时代，人们都在急于得到社会的认可，实现自己的存在和价值，你在步入这个浪潮的同时，也要留意在身后默默支持着你的家人，朋友，重要的人。前人留下的宝贵精神财富，也不应被舍弃，值得我们去反复品读和体会。</p>]]></content>
    
    
    <summary type="html">紫罗兰永恒花园</summary>
    
    
    
    <category term="电影" scheme="https://wjldarling.top/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="https://wjldarling.top/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>2022.12.04</title>
    <link href="https://wjldarling.top/posts/6e4d762c.html"/>
    <id>https://wjldarling.top/posts/6e4d762c.html</id>
    <published>2022-12-04T12:21:28.000Z</published>
    <updated>2022-12-04T12:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>  这周是在家隔离的一周，上周急匆匆回到老家，健康码变黄了，居家隔离，天天有人上门做核酸，有时候下午还要做抗原捅鼻子，我第一次捅鼻子，怪不带劲嘞。</p><p>  这周在我姨奶家，她家起的比较晚，上午九点多才起来洗漱吃饭，吃完饭上午稍微学一会，或者看看消息啥的，到中午饭，中午吃过饭之后开始学习，主要下午暖和一点，学一下午，晚上吃完饭再学会，学到九点多就上床了。这天是真冷，在学校有暖气睡觉挺暖和的，但是在家里天天冻的手邦凉，坐那待戴着帽子，腿上盖个衣服，有一天晚上睡觉，一晚上脚都没暖热，后来发现好像是漏风了。</p><p>  这周主要给 ajax，axios 学完了，然后又看了看 promise 函数的仔细讲解以及源码实现，源码实现看了一半，然后今天开始搞尚硅谷的 vue 项目——商品汇。本来以为是个挺厉害的项目嘞，结果进去一看，熟悉的品优购页面，这页面太熟悉不过了，pink 老师讲的，带着敲的页面，现在用 vue 框架又完善具体内容，真的是贯穿前端基础。</p><p>  然后就是学习之余，看视频推荐的一款游戏——霓虹深渊:无限，就去玩了，挺有意思的（doge），跟元气骑士一个类型的肉鸽游戏。</p>]]></content>
    
    
    <summary type="html">2022.12.04</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>难过</title>
    <link href="https://wjldarling.top/posts/51e2c81d.html"/>
    <id>https://wjldarling.top/posts/51e2c81d.html</id>
    <published>2022-11-27T13:45:35.000Z</published>
    <updated>2022-11-27T13:45:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>  这一周过的五味杂陈。</p><p>  本来在学校学的好好的，但是又有试管异常，然后进行封控，所幸不是我们楼，学校也感觉可能会再有病例，以及教育部通知啥的，决定让学生请假离校，然后也陆续有学生请假回家，我本来打算假期在外面租个房子嘞，然后在园区学习，想着万一疫情严重了过年就不回去了，现在想想真是愚蠢。</p><p>  在 11.25 号那天，中午刚吃饭完在宿舍躺着呢，突然我妈视频打过来了，然后给我说我奶快不行了，叫我收拾东西回趟家，再给我爷打电话，我心里一下就非常难受，挂掉电话之后，赶紧给我爷打电话，一接通，我一下就哭出来了，我爷那边也是一直擤鼻涕，我俩沉默了半天，我爷说：“你奶有病了，治不好了，你那边管回来回来，回不来就算了。。。” 我说：“管回去，我今儿就回去。。。” 挂断电话，我超级难受，再给我爸打电话，我爸给我说你奶奶去世了，我本来想着我爷说的我奶奶应该还有一口气等着我们回去呢，然后也没多想，想着赶紧回家，然后就开始找车票，剩一张一等票，然后买完就赶紧给导员请假，收拾行李，晚上七点的车，等到四点吃了顿饭，四点半去坐学校的大巴车，然后到高铁站等车，七点上车，八点到地方，在车上我还给我对象说了情况（之前我奶知道我谈了个女朋友但是只看过照片），她说等我回家给我打视频让我奶看看她，我爸一个卡点等着接我，我出站打了个的跑了三十多公里到我爸找我的地方，然后一块回家了，到家已经是晚上十一点了，我进门就看到我奶躺在一个水晶棺里，盖着白布，那一瞬间，真的，我想哭，却不知为何哭不出来了。。。</p><p>  从小我就跟我爷我奶在一起生活，我爸我妈出去打工，小时候我妈出去打工好久才回来，进门我第一声喊了个’阿姨‘，我妈一下就哭出来了。他们在我 3 岁的时候就把我放在家里，爷爷奶奶带大的，奶奶特别疼我，她在我小时候就患了好多病。还记得小学的时候，让写长大后的愿望，我写的就是当医生，给我奶奶治病。。。我也没当上医生，我奶奶也没等到我大学毕业。</p><p>  常回家看看亲人，在外上学也好，打工也好，回家的次数本来就不多，能回家就尽量回家吧，真到哪天看不到了再回去，一切都晚了。</p>]]></content>
    
    
    <summary type="html">我没有奶奶了</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>2022.11.20</title>
    <link href="https://wjldarling.top/posts/49a37f59.html"/>
    <id>https://wjldarling.top/posts/49a37f59.html</id>
    <published>2022-11-20T09:25:09.000Z</published>
    <updated>2022-11-20T09:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>  这周还是在封控中，每天都在宿舍，本来说实验室好像开了，但是感觉快闭组了准备准备期末考试，学习的话到 js 的十大算法了，也待学一段时间嘞，准备下周学学。</p><p>  这周主要是看了海贼，差不多两百集，真得好看，打凯多打了一百集还没打完，等着开 5 档，还有好多剧场版没有看。然后进行了肉品仿真模拟实验，那垃圾实验系统老出 bug，德州扒鸡实验重复了五六回，做 yue 了都。我室友直接穿模跑到地图外面，又是重新来过。</p><p>  每天固定流程早上起来就去做核酸，然后十点多了再买个饭，早饭午饭一块吃了。每天都是如此。前两天封控，在寝室待一天待到无聊，真的没事干，又不太想学习，提不起劲。然后找到了一本书《javascript 百炼成仙》，这本书是 javascript 与修仙题材结合起来的一本书，主人公一步一步掌握 js 的知识，从易到难慢慢引出，看着确实比那些专门讲知识点的书要有意思，是第一本技术与修仙结合的书籍，写的虽然有些不足，但是也值得一看。</p><p>  这新乡的疫情，最近都比较严重，也不知道期末考试会不会线上，如果线上的话我直接不复习了，继续学习阶段知识（doge），小问题小问题。</p>]]></content>
    
    
    <summary type="html">2022.11.20</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>《高效能人士的七个习惯》</title>
    <link href="https://wjldarling.top/posts/109f566b.html"/>
    <id>https://wjldarling.top/posts/109f566b.html</id>
    <published>2022-11-13T12:43:43.000Z</published>
    <updated>2022-11-13T12:43:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>  最近看了一本书籍名叫《高效能人士的七个习惯》，讲述了成功亦或是有成就的人具有的七个好习惯。</p><p><strong>习惯一:积极主动(BE PROACTIVE)</strong></p><p>  积极主动即采取主动，为自己过去、现在及未来的行为负责，并依据原则及价值观，而非情绪或外在环境来下决定。积极主动的人是改变的催生者，他们摒弃被动的受害者角色，不怨天尤人，发挥了人类四项独特的禀赋——自我意识、良知、想象力和独立意志，同时以由内而外的方式来创造改变，积极面对一切。他们选择创造自己的人生，这也是每个人最基本的决定。</p><p>  如果学生不肯发问，不肯暴露自己的无知，不肯让老师知道他的人正水平，那么绝对学不到东西，也就不能有长进。而且伪装实非长久之计，总有被拆穿的一天。承认自己的无知往往是求知的第一步。梭罗曾说:“如果我们时时忙着展现自己的知识，将何从忆起成长所需的无知?”</p><p><strong>习惯二:以终为始（BEGIN WITH THE END IN MIND)</strong></p><p>  所有事物都经过两次的创造——先是在脑海里酝酿，其次才是实质的创造。个人、家庭、团队和组织在做任何计划时，均先拟出愿景和目标，并据此塑造未来，全心投入自己最重视的原则、价值观、关系及目标。对个人、家庭或组织而言，使命宣言可以说是愿景的最高形式，它是根本的决策，主宰了所有其他决定。领导工作的核心，就是基于共有的使命、愿景和价值观，创造出一个文化。</p><p><strong>习惯三:要事第一(PUT FIRST THINGS FIRST)</strong></p><p>  要事第一即实质的创造，是梦想（你的目标、愿景、价值观及要事处理顺序)的组织与实践。次要的事不必摆在第一，要事也不能放在第二。无论迫切性如何，个人与组织均要更多聚焦要事，重点是，把要事放在第一位。</p><p><strong>习惯四:双赢思维（THINK WIN-WIN)</strong></p><p>  双嬴思维是一种基于互敬、寻求互惠的思考框架与心意，目的是分享更多的机会、财富及资源，而非敌对式竞争。双赢既非损人利己（赢输），亦非损己利人（输赢）。我们的工作伙伴及家庭成员要从互赖式的角度来思考(“我们”，而非“我”)。双赢思维鼓励我们解决问题，并协助个人找到互惠的解决办法，是一种资讯、力量、认可及报酬的分享。</p><p><strong>习惯五:知彼解己（SEEK FIRST TO UNDERSTAND,THEN TO BE UNDERSTOOD)</strong></p><p>  当我们不再急切回答，改以诚心去了解、聆听别人，便能开启真正的沟通，增进彼此关系。对方获得理解后，会觉得受到尊重与认可，进而卸下心理防备，坦然交谈，双方对彼此的了解也就更顺畅自然。知彼需要仁慈心，解己需要勇气，能平衡两者，则可大幅提升沟通的效率。</p><p><strong>习惯六:统合综效(SYNERGIZE)</strong></p><p>  统合综效谈的是创造第三种选择，即非按照我的方式，亦非遵循你的方式，而是创造第三种更好的办法。它是互相尊重的成果——不但了解了彼此，甚至还称赞彼此的差异，欣赏对方解决问题及把握机会的手法。个人的力量是团队和家庭统合综效的基础，能使整体获得一加一大于二的成效。实践统合综效的人际关系和团队会扬弃敌对的态度（1+1=0.5），不以妥协为目标（1+1=1.5），也不仅仅止于合作（1+1=2)，他们要的是创造式的合作（1 ＋ 1&gt;2)。</p><p><strong>习惯七:不断更新(SHARPEN THE SAW)</strong></p><p>  “不断更新&quot;谈的是，如何在四个生活基本面(身体、精神、智力、社会/情感)中，不断更新自己。这个习惯提升了其他六个习惯的实施效率。对组织而言，习惯七提供了愿景、更新及不断的改善，使组织不至呈现老化及疲态，并迈向新的成长之路。对家庭而言，习惯七通过固定的个人及家庭活动，使家庭效能升级，就像建立传统，使家庭日新月异，即是一例。</p>]]></content>
    
    
    <summary type="html">《高效能人士的七个习惯》</summary>
    
    
    
    <category term="读书" scheme="https://wjldarling.top/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书有感" scheme="https://wjldarling.top/tags/%E8%AF%BB%E4%B9%A6%E6%9C%89%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>2022.11.06</title>
    <link href="https://wjldarling.top/posts/92f6b8ee.html"/>
    <id>https://wjldarling.top/posts/92f6b8ee.html</id>
    <published>2022-11-06T10:05:10.000Z</published>
    <updated>2022-11-06T10:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  这一周也是解封之后的第一周，连着封了十天，天天寝室门都不让出，天天食不果腹，三天饿九顿，晚上还要爬起来泡泡面，属实不待，不过问题不大，有饭就能活。</p><p>  这周去小组学习了一周，前三天一直再搞 vue 作品，刚开始学完也是一脸懵逼，作品啥的一点思路都没有，然后不会的就问问别人，再搜搜，三天终于是搞完了，然后周四复习了一天知识点，感觉复习的七七八八了，晚上去考核，发现学长学姐也是问了一堆问题，感觉有不少答不上来，就跟之前的一样，知道这个东西，大概了解，但是讲不出来，归根结底还是不懂，还待更深入学习，学长学姐问了好多有营养的问题感觉，好像有的问题没有记上，也科普了好些。收获挺大的。考核完回来之后花了一天总结了考核的问题，又补充了一些自己不了解的，然后问学长学姐要了他们俩记的笔记，我又花了两天给这些笔记看了看，不会的又搜了搜，发现还是有好些了解不够的，有些还是看不老明白，自己掌握的还是不够，掌握到的都是比较浅显的感觉，作品的话在知识点涉及范围里用的还不错，但是好多知识点都没有用到，还是掌握不够。</p><p>  这次考核真的是收获了好多好多，也回来自己又巩固了好几天，下周的话准备给 javaweb 作品弄完，给数据库知识重新复习一遍，然后就进行分方向，自己也确定了进行前端的学习，以后还待更加努力。</p><p>  再就是感觉这天天在教室学习，属实累了，早上中午睡个觉闹钟都听不见了，唉。</p>]]></content>
    
    
    <summary type="html">2022.11.06</summary>
    
    
    
    <category term="周记" scheme="https://wjldarling.top/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
    <category term="周记" scheme="https://wjldarling.top/tags/%E5%91%A8%E8%AE%B0/"/>
    
    <category term="大学生活" scheme="https://wjldarling.top/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
